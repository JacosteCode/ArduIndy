#include <Arduboy2.h>
#include <EEPROM.h>

#define STATE_MENU_MAIN     1
#define STATE_MENU_PLAY     2
#define STATE_GAME_PLAYING  3
#define STATE_GAME_PAUSE    4
#define STATE_GAME_OVER     5
#define STATE_PAUSED        6
#define STATE_GAME_WON      7

#define SCREEN_WIDTH       95
#define SCREEN_HEIGHT      63
#define MAX_ROOM_X         16
#define MAX_ROOM_Y         16
#define PCT_BIT_BYTES      16
#define ROOM_SIZE_X        12
#define ROOM_SIZE_Y         8
#define WALL_SIZE_X         8
#define WALL_SIZE_Y         8

#define AVATAR_HEIGHT       8
#define AVATAR_WIDTH        8
#define AVATAR_STEP_CHANGE  2

#define GHOST_WIDTH         8
#define GHOST_HEIGHT        8
#define MAX_NUM_OF_GHOST    5
#define GHOST_DETAILS       3
#define GHOST_X             0
#define GHOST_Y             1
#define GHOST_TYPE          2
#define GHOST_TYPE_GHOST1   1
#define GHOST_TYPE_GHOST2   2
#define GHOST_TYPE_HEAD     3
#define GHOST_TYPE_SKULL    4
#define NO_GHOST          255
#define GHOST_STEP_CHANGE   1

#define EXTRA_LIFE_KILL    50
#define MAX_LIVES           6

#define ITEM_WIDTH          8
#define ITEM_HEIGHT         8
#define MAX_NUM_OF_ITEM    15
#define ITEM_DETAILS        3
#define ITEM_X              0
#define ITEM_Y              1
#define ITEM_TYPE           2
#define ITEM_HEART          1
#define ITEM_APPLE          2
#define ITEM_FLOWER         3
#define ITEM_COFFEE         4
#define ITEM_POTION         5
#define ITEM_GRASS          6
#define NO_ITEM           255
#define POTION_LEVEL      450 // 30 frames x 15 seconds

#define BITMAP_POS          2
#define BITMAPS            50
#define BITMAP_X            0
#define BITMAP_Y            1
#define BITMAP_NODATA     255

#define NO_KEYS             4
#define KEY_WIDTH           8
#define KEY_HEIGHT          8

#define EXIT_WIDTH         25
#define EXIT_HEIGHT        12

#define GHOST_KILL_SCORE   10
#define SKULL_KILL_SCORE   50
#define PCT_SCORE          25
#define KEY_SCORE         100

#define DIRECTION_UP        1
#define DIRECTION_DOWN      2
#define DIRECTION_LEFT      3
#define DIRECTION_RIGHT     4

Arduboy2 arduboy;

unsigned char gameState          = STATE_MENU_MAIN;
unsigned char avatarDirection    = 0;

boolean       cheat              = false;
boolean       soundYes           = false;
boolean       facingRight        = true;
boolean       fencing            = false;
boolean       newHiscore         = false;

boolean       keys[NO_KEYS]      = { false, false, false, false };

unsigned int  score              = 0;
unsigned int  hiscore            = 0;
unsigned int  fencingGauge       = 0;
unsigned int  totalKillCounter   = 0;
unsigned int  potionLevel        = 0;
unsigned int  bits[]             = { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768 };
unsigned int  pctBits[PCT_BIT_BYTES];

int           avatarY            = 0;
int           avatarX            = 0;

byte          pct                =  0;
byte          pctHiscore         =  0;
byte          roomX              =  0;
byte          roomY              =  0;
byte          lives              =  0;
byte          avatarFrame        =  0;
byte          coffeeFrame        =  0;
byte          potionFrame        =  0;
byte          heartFrame         =  0;
byte          mainFrame          =  0;
byte          prFrame            =  0;
byte          numberBitMaps      =  0;
byte          currentNumGhosts   =  0;
byte          currentNumItems    =  0;
byte          killCounter        =  0;

byte          roomBitMaps[BITMAPS][BITMAP_POS];
byte          ghosts[MAX_NUM_OF_GHOST][GHOST_DETAILS];
byte          items[MAX_NUM_OF_ITEM][ITEM_DETAILS];

PROGMEM const byte outerWallImg[]            = { 0xEE, 0xEE, 0xEE, 0x00, 0xBB, 0xBB, 0xBB, 0x00 };
PROGMEM const byte innerWallImg[]            = { 0xe6, 0xc6, 0x82, 0x10, 0x30, 0x64, 0xce, 0x00 };
PROGMEM const byte exitRoomWallImg[]         = { 0x08, 0x0c, 0xfe, 0xff, 0xfe, 0x0c, 0x08, 0x00 };

PROGMEM const byte heartImgFull[]            = { 0x0e, 0x3f, 0x7f, 0xfe, 0xfe, 0x7f, 0x3f, 0x0e };
PROGMEM const byte heartImgSmall[]           = { 0x00, 0x1c, 0x3e, 0x7c, 0x7c, 0x3e, 0x1c, 0x00 };
PROGMEM const byte heartImgEmpty[]           = { 0x0e, 0x11, 0x21, 0x42, 0x42, 0x21, 0x11, 0x0e };
PROGMEM const byte heartImgExtra[]           = { 0x18, 0x7e, 0x18 };

PROGMEM const byte avatarLeft1Img[]          = { 0x00, 0x00, 0x84, 0xc8, 0x3f, 0x7f, 0x44, 0xcc };
PROGMEM const byte avatarLeft2Img[]          = { 0x00, 0x00, 0x10, 0x88, 0xff, 0x7f, 0xcc, 0x00 };
PROGMEM const byte avatarLeft1fencingImg[]   = { 0x01, 0x02, 0x84, 0xc8, 0x3f, 0x7f, 0x44, 0xcc };
PROGMEM const byte avatarLeft2fencingImg[]   = { 0x40, 0x20, 0x10, 0x88, 0xff, 0x7f, 0xcc, 0x00 };
PROGMEM const byte avatarRight1Img[]         = { 0xcc, 0x44, 0x7f, 0x3f, 0xc8, 0x84, 0x00, 0x00 };
PROGMEM const byte avatarRight2Img[]         = { 0x00, 0xcc, 0x7f, 0xff, 0x88, 0x10, 0x00, 0x00 };
PROGMEM const byte avatarRight1fencingImg[]  = { 0xcc, 0x44, 0x7f, 0x3f, 0xc8, 0x84, 0x02, 0x01 };
PROGMEM const byte avatarRight2fencingImg[]  = { 0x00, 0xcc, 0x7f, 0xff, 0x88, 0x10, 0x20, 0x40 };
PROGMEM const byte avatarLeftFallImg[]       = { 0x00, 0x00, 0xc0, 0x90, 0xfc, 0xfc, 0x30, 0x00 };
PROGMEM const byte avatarRightFallImg[]      = { 0x00, 0x30, 0xfc, 0xfc, 0x90, 0xc0, 0x00, 0x00 };

PROGMEM const byte ghost1FullImg[]           = { 0xfc, 0x7e, 0xfb, 0x7f, 0xfb, 0x7e, 0xfc, 0x00 };
PROGMEM const byte ghost2FullImg[]           = { 0xfc, 0x7e, 0xeb, 0x6f, 0xeb, 0x7e, 0xfc, 0x00 };
PROGMEM const byte headFullImg[]             = { 0x00, 0x1e, 0x71, 0x45, 0x51, 0x45, 0x71, 0x1e };
PROGMEM const byte skullFullImg[]            = { 0x00, 0x1e, 0xf3, 0x3b, 0xef, 0x3b, 0xf3, 0x1e };

PROGMEM const byte enemyKill1Img[]           = { 0x00, 0x49, 0x2a, 0x00, 0x63, 0x00, 0x2a, 0x49 };
PROGMEM const byte enemyKill2Img[]           = { 0x00, 0x49, 0x00, 0x00, 0x41, 0x00, 0x00, 0x49 };

PROGMEM const byte flowerImg[]               = { 0x00, 0x18, 0x32, 0x67, 0x7f, 0x67, 0x32, 0x18 };
PROGMEM const byte appleImg[]                = { 0x00, 0x38, 0x44, 0xbc, 0x7b, 0xfd, 0x7c, 0x38 };
PROGMEM const byte coffee1Img[]              = { 0x00, 0x78, 0xf8, 0xfd, 0xfa, 0xf8, 0x48, 0x30 };
PROGMEM const byte coffee2Img[]              = { 0x00, 0x78, 0xf8, 0xfa, 0xfd, 0xf8, 0x48, 0x30 };
PROGMEM const byte potion1Img[]              = { 0x00, 0x70, 0xd8, 0xff, 0xaf, 0xf8, 0x70, 0x00 };
PROGMEM const byte potion2Img[]              = { 0x00, 0x70, 0xf8, 0xaf, 0xff, 0xd8, 0x70, 0x00 };
PROGMEM const byte grassImg[]                = { 0x00, 0x00, 0x0c, 0x10, 0x08, 0x04, 0x00, 0x00 };

PROGMEM const byte keyImg[]                  = { 0x00, 0x00, 0xa6, 0xa9, 0xf9, 0x06, 0x00, 0x00 };

PROGMEM const byte fenceImg[]                = { 0xfe, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xfe, 0x00 };

PROGMEM const byte gameOverImg[]             = { 0xfc, 0xfe, 0xf7, 0xc3, 0xf7, 0xfe, 0xfc, 0x00 };

PROGMEM const byte exitImg[]                 = { 0xf8, 0x0c, 0xea, 0xa9, 0xa9, 0x29, 0x09, 0x29, 0x49, 0x89, 0x49, 0x29, 0x09, 0xe9, 0x09, 0x29, 0x29, 0xe9, 0x29, 0x29, 0x09, 0xf9, 0x05, 0x03, 0xff, 0x0f, 0x08, 0x0b, 0x0a, 0x0a, 0x0a, 0x08, 0x0a, 0x09, 0x08, 0x09, 0x0a, 0x08, 0x0b, 0x08, 0x08, 0x08, 0x0b, 0x08, 0x08, 0x08, 0x0f, 0x04, 0x02, 0x01 };

PROGMEM const unsigned char img1Main[]       = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x8f, 0xe7, 0xf3, 0xfb, 0xfb, 0xfb, 0xfb, 0x7b, 0x13, 0xc7, 0xff, 0xff, 0x7f, 0x0f, 0xe7, 0xf7, 0xf3, 0x3b, 0xbb, 0xbb, 0x73, 0xf7, 0xf7, 0xe7, 0x6f, 0x0f, 0xff, 0x7f, 0x0f, 0xe7, 0xf7, 0xf7, 0x77, 0x77, 0xf7, 0xf7, 0xe7, 0xcf, 0x1f, 0xff, 0xff, 0x7f, 0x1f, 0xc7, 0xf3, 0xfb, 0x3b, 0x8b, 0xe3, 0xff, 0x1f, 0xc7, 0xf3, 0xfb, 0x7b, 0x0b, 0xe3, 0x1f, 0x47, 0x73, 0xfb, 0xfb, 0xfb, 0xfb, 0x7b, 0x7b, 0x7b, 0x3b, 0x8b, 0xe3, 0x7f, 0x0f, 0xe7, 0xf7, 0xf3, 0xfb, 0x03, 0x7f, 0x1f, 0xc3, 0xfb, 0xf3, 0x37, 0x87, 0xff, 0x1f, 0xc7, 0xf7, 0xf7, 0xf7, 0x77, 0x77, 0xf7, 0xe7, 0xef, 0xcf, 0x1f, 0xff, 0xff, 0x07, 0xf7, 0xf7, 0xf7, 0x07, 0xbf, 0x8f, 0xe7, 0xf7, 0x77, 0x37, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x8f, 0xe7, 0xf1, 0xfc, 0x7f, 0x1f, 0x07, 0xf3, 0xff, 0xff, 0xff, 0x0f, 0xe0, 0xff, 0x3f, 0x8f, 0xe3, 0xf8, 0xff, 0x7f, 0x7f, 0xfb, 0xf8, 0xdd, 0x1c, 0x4e, 0xe7, 0xf3, 0xf8, 0x7e, 0x1f, 0xc3, 0xf8, 0xff, 0xbf, 0x83, 0xd8, 0xce, 0xe7, 0x70, 0x3f, 0x9f, 0xc7, 0xf0, 0x1f, 0xc3, 0xf8, 0xff, 0xff, 0x87, 0xb0, 0x9e, 0xcf, 0xe3, 0x78, 0x3e, 0x9f, 0xc7, 0xf1, 0xfc, 0x7f, 0x1f, 0xc3, 0xf8, 0xff, 0xff, 0x7f, 0x1f, 0xc7, 0xf0, 0xff, 0xff, 0x3f, 0x8f, 0xe3, 0xf8, 0x7f, 0x1f, 0x3f, 0xff, 0xff, 0xff, 0xfc, 0xff, 0x1f, 0xc3, 0xf8, 0x3e, 0x87, 0xf1, 0xfc, 0xff, 0x9f, 0xc3, 0xd8, 0xce, 0x63, 0x38, 0x9f, 0xcf, 0xe3, 0xf8, 0x7f, 0x0f, 0xe0, 0xff, 0xff, 0x3f, 0x8f, 0xe7, 0xf3, 0xf9, 0xfc, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x1f, 0x47, 0x71, 0x7c, 0x7f, 0x3f, 0x8f, 0xe7, 0xf7, 0x17, 0x47, 0x7f, 0x7f, 0x7f, 0x3f, 0x81, 0xfc, 0xf3, 0xf0, 0xf6, 0xf7, 0xf7, 0xf1, 0xfc, 0xff, 0xf0, 0xf7, 0xf3, 0xfb, 0xfb, 0xf8, 0xff, 0xff, 0xf1, 0xf4, 0xf7, 0xf7, 0xf3, 0xfb, 0xfb, 0xf9, 0xfd, 0xfc, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfc, 0xf9, 0xfb, 0xfb, 0xfb, 0xfb, 0xf9, 0xfd, 0xfc, 0xfe, 0xff, 0x8f, 0xa3, 0xbb, 0xb9, 0xbc, 0xbf, 0xbf, 0xbf, 0xbf, 0x9f, 0xcc, 0xe5, 0xf1, 0xff, 0xf7, 0xf0, 0xf6, 0xf7, 0xf3, 0xf3, 0xf8, 0xff, 0xfe, 0xf8, 0xfb, 0xfb, 0xfb, 0xf8, 0xfe, 0xff, 0xf0, 0xf6, 0xf7, 0xf3, 0xfb, 0xfb, 0xfb, 0xf9, 0xfd, 0xfc, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xf1, 0xf4, 0xf7, 0xf7, 0xf7, 0xf0, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xbf, 0x7f, 0xbf, 0xc7, 0xff, 0x1b, 0x6d, 0x6d, 0x6d, 0x73, 0xff, 0x3f, 0x3f, 0xff, 0x83, 0x5d, 0x6d, 0x75, 0x83, 0xff, 0x83, 0x5d, 0x6d, 0x75, 0x83, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x83, 0x6f, 0x6f, 0x6f, 0x9f, 0xff, 0x8f, 0x7f, 0x7f, 0x7f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0x7f, 0x7b, 0x7b, 0x83, 0xff, 0x07, 0xdb, 0xdb, 0xdb, 0x07, 0xff, 0x87, 0x7b, 0x7b, 0x7b, 0xb7, 0xff, 0x87, 0x7b, 0x7b, 0x7b, 0x87, 0xff, 0xb7, 0x6b, 0x6b, 0x6b, 0x9b, 0xff, 0xfb, 0xfb, 0x03, 0xfb, 0xfb, 0xff, 0x03, 0x6b, 0x6b, 0x7b, 0x7b, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0d, 0x0b, 0x0b, 0x0b, 0x0c, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f };
PROGMEM const unsigned char img2Main[]       = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x0f, 0x07, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xc7, 0xff, 0xff, 0x7f, 0x0f, 0x07, 0x07, 0x03, 0x03, 0x83, 0x83, 0x03, 0x07, 0x07, 0x07, 0x0f, 0x0f, 0xff, 0x7f, 0x0f, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x0f, 0x1f, 0xff, 0xff, 0x7f, 0x1f, 0x07, 0x03, 0x03, 0x03, 0x83, 0xe3, 0xff, 0x1f, 0x07, 0x03, 0x03, 0x03, 0x03, 0xe3, 0x1f, 0x07, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x83, 0xe3, 0x7f, 0x0f, 0x07, 0x07, 0x03, 0x03, 0x03, 0x7f, 0x1f, 0x03, 0x03, 0x03, 0x07, 0x87, 0xff, 0x1f, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x0f, 0x0f, 0x1f, 0xff, 0xff, 0x07, 0x07, 0x07, 0x07, 0x07, 0x3f, 0x0f, 0x07, 0x07, 0x07, 0x07, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x0f, 0x07, 0x01, 0x00, 0x00, 0x00, 0x60, 0x38, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x3f, 0x0f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x40, 0xe0, 0xf0, 0xf8, 0x7e, 0x1f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x18, 0x0e, 0x07, 0x00, 0x00, 0x80, 0xc0, 0xf0, 0x1f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x30, 0x1e, 0x0f, 0x03, 0x00, 0x00, 0x80, 0xc0, 0xf0, 0xfc, 0x7f, 0x1f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xf0, 0xff, 0xff, 0x3f, 0x0f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xf8, 0x3e, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x18, 0x0e, 0x03, 0x00, 0x80, 0xc0, 0xe0, 0xf8, 0x7f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x1f, 0x07, 0x01, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xf0, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xfc, 0xf3, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xfc, 0xff, 0xf0, 0xf0, 0xf0, 0xf8, 0xf8, 0xf8, 0xff, 0xff, 0xf1, 0xf0, 0xf0, 0xf0, 0xf0, 0xf8, 0xf8, 0xf8, 0xfc, 0xfc, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfc, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xfc, 0xfc, 0xfe, 0xff, 0x8f, 0x83, 0x83, 0x81, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xc0, 0xe1, 0xf1, 0xff, 0xf7, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf8, 0xff, 0xfe, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xfe, 0xff, 0xf0, 0xf0, 0xf0, 0xf0, 0xf8, 0xf8, 0xf8, 0xf8, 0xfc, 0xfc, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xf1, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xbf, 0x7f, 0xbf, 0xc7, 0xff, 0x1b, 0x6d, 0x6d, 0x6d, 0x73, 0xff, 0x3f, 0x3f, 0xff, 0x83, 0x5d, 0x6d, 0x75, 0x83, 0xff, 0x83, 0x5d, 0x6d, 0x75, 0x83, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x83, 0x6f, 0x6f, 0x6f, 0x9f, 0xff, 0x8f, 0x7f, 0x7f, 0x7f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0x7f, 0x7b, 0x7b, 0x83, 0xff, 0x07, 0xdb, 0xdb, 0xdb, 0x07, 0xff, 0x87, 0x7b, 0x7b, 0x7b, 0xb7, 0xff, 0x87, 0x7b, 0x7b, 0x7b, 0x87, 0xff, 0xb7, 0x6b, 0x6b, 0x6b, 0x9b, 0xff, 0xfb, 0xfb, 0x03, 0xfb, 0xfb, 0xff, 0x03, 0x6b, 0x6b, 0x7b, 0x7b, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0d, 0x0b, 0x0b, 0x0b, 0x0c, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f };

PROGMEM const unsigned int mapBits[]         = { 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x800, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x800, 0xFF1, 0xFFF, 0xFFF, 0xFFF, 0x801, 0xFFF, 0xFFF, 0x801, 0xFFF, 0xFFF, 0xE07, 0xFFF, 0xFFF, 0xFFF, 0x803, 0x801, 0x1, 0x0, 0x0, 0x100, 0x801, 0x0, 0x0, 0x801, 0x1, 0x200, 0x4, 0x0, 0x200, 0x0, 0x802, 0x801, 0x1, 0x0, 0x0, 0x100, 0x801, 0x0, 0x0, 0x801, 0x1, 0x200, 0x4, 0x0, 0x200, 0x0, 0x802, 0x801, 0x1, 0x0, 0x0, 0x100, 0x801, 0x0, 0x0, 0x801, 0x1, 0x200, 0x4, 0x0, 0x200, 0x0, 0x802, 0x801, 0xFFF, 0xFFF, 0xFFF, 0xF1F, 0xFC3, 0xFFF, 0xFFF, 0xF8F, 0xFFF, 0xF87, 0xFFF, 0xFFF, 0xF8F, 0xFFF, 0xF0F, 0xF87, 0xFFF, 0xFFF, 0xFFF, 0xF1F, 0xFC3, 0xFFF, 0xFFF, 0xF8F, 0xFFF, 0xF87, 0xFFF, 0xFFF, 0xF8F, 0xFFF, 0xF0F, 0xF87, 0x1, 0x200, 0x2, 0x100, 0x2, 0x800, 0x1, 0x400, 0x2, 0x80, 0x1, 0x200, 0x4, 0x0, 0x0, 0x804, 0x1, 0x200, 0x2, 0x100, 0x2, 0x800, 0x1, 0x400, 0x2, 0x80, 0x1, 0x200, 0x4, 0x0, 0x0, 0x804, 0xFF1, 0xE3F, 0xC0F, 0xF07, 0xFFF, 0x8C7, 0xE31, 0xFFF, 0xE1F, 0xFFF, 0xFFF, 0xE0F, 0xFFF, 0xFFF, 0xC03, 0x87F, 0x1, 0x200, 0x2, 0x100, 0x2, 0x800, 0x1, 0x400, 0x2, 0x80, 0x1, 0x200, 0x4, 0x0, 0x0, 0x800, 0x1, 0x200, 0x2, 0x100, 0x2, 0x800, 0x1, 0x400, 0x2, 0x80, 0x1, 0x200, 0x4, 0x0, 0x0, 0x800, 0x1, 0x200, 0x2, 0x100, 0x2, 0x800, 0x1, 0x400, 0x2, 0x80, 0x1, 0x200, 0x4, 0x0, 0x0, 0x800, 0xFF1, 0xE3F, 0xF1F, 0xFFF, 0xF0F, 0xFFF, 0xFFF, 0xF8F, 0xE3F, 0xF8F, 0xF8F, 0xFC7, 0xFC7, 0xFFF, 0xF0F, 0xFFF, 0xFF1, 0xE3F, 0xF1F, 0xFFF, 0xF0F, 0xFFF, 0xFFF, 0xF8F, 0xE3F, 0xF8F, 0xF8F, 0xFC7, 0xFC7, 0xFFF, 0xF0F, 0xFFF, 0x11, 0x201, 0x101, 0x1, 0x0, 0x800, 0x801, 0x888, 0x201, 0x4, 0x200, 0x44, 0x42, 0xC03, 0x4, 0x800, 0x11, 0x201, 0x101, 0x1, 0x0, 0x800, 0x801, 0x988, 0x201, 0x4, 0x200, 0xC4, 0xC2, 0xC03, 0x4, 0x800, 0xFF1, 0xFF1, 0xFF1, 0xC71, 0xC03, 0x8E3, 0xC03, 0x90F, 0xFF1, 0xFFF, 0xFFF, 0x87, 0x82, 0x801, 0xFFF, 0x87F, 0x11, 0x101, 0x101, 0x1, 0x0, 0x800, 0x801, 0xB08, 0x201, 0x4, 0x200, 0x184, 0x182, 0x801, 0x4, 0x800, 0x11, 0x101, 0x101, 0x1, 0x0, 0x800, 0x801, 0xA08, 0x201, 0x4, 0x200, 0x104, 0x102, 0xC03, 0x4, 0x800, 0x11, 0x101, 0x101, 0x1, 0x0, 0x800, 0x801, 0xA08, 0x201, 0x4, 0x200, 0x104, 0x102, 0xC03, 0x4, 0x800, 0xFF1, 0xF1F, 0xF1F, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF8F, 0xE3F, 0xF8F, 0xF8F, 0xFC7, 0xF8F, 0xF1F, 0xFC7, 0xC7F, 0xFF1, 0xF1F, 0xF1F, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF8F, 0xE3F, 0xF8F, 0xF8F, 0xFC7, 0xF8F, 0xF1F, 0xFC7, 0xC7F, 0x211, 0x910, 0x10, 0x800, 0x801, 0x801, 0x101, 0x2, 0x200, 0x801, 0x1, 0x0, 0x0, 0x800, 0x1, 0x808, 0x211, 0xA10, 0x10, 0x800, 0x801, 0x801, 0x101, 0x2, 0x200, 0x801, 0x1, 0x0, 0x0, 0x800, 0x1, 0x808, 0xE11, 0xC1F, 0xFFF, 0x8E7, 0x801, 0x801, 0xFE1, 0xF83, 0x23F, 0x801, 0xF0F, 0xF0F, 0xF81, 0x80F, 0xFFF, 0x87F, 0x211, 0x810, 0x10, 0x800, 0x801, 0x801, 0x101, 0x2, 0x200, 0x801, 0x1, 0x108, 0x80, 0x808, 0x1, 0x800, 0x211, 0xF10, 0x10, 0x800, 0x801, 0x801, 0x101, 0x2, 0x200, 0x801, 0x1, 0x108, 0x80, 0x808, 0x1, 0x800, 0x211, 0x910, 0x10, 0x800, 0x801, 0x801, 0x101, 0x2, 0x200, 0x801, 0x1, 0x108, 0x80, 0x808, 0x1, 0x800, 0xFF1, 0xF1F, 0xF1F, 0xFFF, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xFFF, 0xFFF, 0xF1F, 0xF0F, 0xF8F, 0xF8F, 0xFC3, 0xFFF, 0xFF1, 0xF1F, 0xF1F, 0xFFF, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xFFF, 0xFFF, 0xF1F, 0xF0F, 0xF8F, 0xF8F, 0xFC3, 0xFFF, 0x1, 0x200, 0x101, 0x801, 0x801, 0x308, 0x801, 0x1, 0x0, 0x0, 0x200, 0xB04, 0x801, 0x801, 0x1, 0x800, 0x1, 0x200, 0x101, 0x801, 0x801, 0xE08, 0x801, 0x1, 0x0, 0x0, 0x200, 0xE04, 0x801, 0x801, 0x1, 0x800, 0xFE1, 0xE3F, 0xFE1, 0x801, 0x801, 0xC0F, 0xFE1, 0x8F1, 0xFFF, 0xFFF, 0xE1F, 0xC07, 0xFE1, 0x801, 0xF81, 0x83F, 0x1, 0x200, 0x101, 0x801, 0x801, 0x808, 0x801, 0x1, 0x0, 0x0, 0x200, 0x804, 0x801, 0x801, 0x1, 0x800, 0x1, 0x200, 0x101, 0x801, 0x801, 0x808, 0x801, 0x1, 0x0, 0x0, 0x200, 0x804, 0x801, 0x801, 0x1, 0x800, 0x1, 0x200, 0x101, 0x801, 0x801, 0x808, 0x801, 0x1, 0x0, 0x0, 0x200, 0x804, 0x801, 0x801, 0x1, 0x800, 0xFF1, 0xFFF, 0xF1F, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xF0F, 0xF8F, 0xFFF, 0xFC3, 0xC7F, 0xFF1, 0xFFF, 0xF1F, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xF0F, 0xF8F, 0xFFF, 0xFC3, 0xC7F, 0x1, 0x200, 0x801, 0x1, 0x0, 0x200, 0x4, 0x800, 0x801, 0x801, 0x1, 0x400, 0xB02, 0x1, 0x0, 0x808, 0x1, 0x200, 0x801, 0x1, 0x0, 0x200, 0x4, 0x800, 0x801, 0x801, 0x1, 0x400, 0xE02, 0x1, 0x0, 0x808, 0xFE1, 0xE3F, 0x801, 0xFF1, 0xFFF, 0xE1F, 0xFFF, 0x8F1, 0x801, 0x801, 0x8F1, 0xFFF, 0x80F, 0x8F1, 0x801, 0x8FF, 0x1, 0x200, 0x801, 0x1, 0x0, 0x200, 0x4, 0x800, 0x801, 0x801, 0x1, 0x400, 0x802, 0x1, 0x0, 0x800, 0x1, 0x200, 0x801, 0x1, 0x0, 0x200, 0x4, 0x800, 0x801, 0x801, 0x1, 0x400, 0x802, 0x1, 0x0, 0x800, 0x1, 0x200, 0x801, 0x1, 0x0, 0x200, 0x4, 0x800, 0x801, 0x801, 0x1, 0x400, 0x802, 0x1, 0x0, 0x800, 0xFF1, 0xF1F, 0xF1F, 0xFC3, 0xFFF, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xF87, 0xFFF, 0xFC3, 0xFFF, 0xFF1, 0xF1F, 0xF1F, 0xFC3, 0xFFF, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xF87, 0xFFF, 0xFC3, 0xFFF, 0x1, 0x200, 0x4, 0x0, 0x0, 0x800, 0x1, 0x0, 0x0, 0x8, 0x800, 0x401, 0x2, 0x0, 0x100, 0x800, 0x1, 0x200, 0x4, 0x0, 0x0, 0x800, 0x1, 0x0, 0x0, 0x8, 0x800, 0x401, 0x2, 0x0, 0x100, 0x800, 0xFE1, 0xFFF, 0xFFF, 0x801, 0xFFF, 0x871, 0xFFF, 0xFFF, 0x801, 0xFFF, 0x8F1, 0xFF1, 0xFFF, 0xFFF, 0xFFF, 0x83F, 0x1, 0x200, 0x4, 0x0, 0x0, 0x800, 0x1, 0x0, 0x0, 0x8, 0x800, 0x401, 0x2, 0x0, 0x100, 0x800, 0x1, 0x200, 0x4, 0x0, 0x0, 0x800, 0x1, 0x0, 0x0, 0x8, 0x800, 0x401, 0x2, 0x0, 0x100, 0x800, 0x1, 0x200, 0x4, 0x0, 0x0, 0x800, 0x1, 0x0, 0x0, 0x8, 0x800, 0x401, 0x2, 0x0, 0x100, 0x800, 0xFF1, 0xF1F, 0xF1F, 0xF0F, 0xFFF, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xF8F, 0xFFF, 0xF8F, 0xE3F, 0xFF1, 0xF1F, 0xF1F, 0xF0F, 0xFFF, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xF8F, 0xFFF, 0xF8F, 0xE3F, 0x111, 0x8, 0x200, 0x801, 0x801, 0x1, 0x0, 0x108, 0x0, 0x108, 0x800, 0x1, 0x200, 0x1, 0x100, 0x800, 0x111, 0x8, 0x200, 0x801, 0x801, 0x1, 0x0, 0x108, 0x0, 0x108, 0x800, 0x1, 0x200, 0x1, 0x100, 0x800, 0xF11, 0xFFF, 0xFFF, 0x801, 0x801, 0x8F1, 0x801, 0xF0F, 0xFE1, 0xF0F, 0x8F1, 0xFFF, 0xFFF, 0x8F1, 0xFFF, 0x83F, 0x111, 0x8, 0x200, 0x801, 0x801, 0x1, 0x0, 0x0, 0x0, 0x0, 0x800, 0x1, 0x200, 0x1, 0x100, 0x800, 0x111, 0x8, 0x200, 0x801, 0x801, 0x1, 0x0, 0x0, 0x0, 0x0, 0x800, 0x1, 0x200, 0x1, 0x100, 0x800, 0x111, 0x8, 0x200, 0x801, 0x801, 0x1, 0x0, 0x0, 0x0, 0x0, 0x800, 0x1, 0x200, 0x1, 0x100, 0x800, 0xFF1, 0xF1F, 0xF1F, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF8F, 0xFFF, 0xF8F, 0xF0F, 0xFF1, 0xF1F, 0xF1F, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF8F, 0xFFF, 0xF8F, 0xF0F, 0x1, 0x0, 0x0, 0x0, 0x800, 0x801, 0x201, 0x801, 0x801, 0x801, 0x801, 0x201, 0x4, 0x0, 0x100, 0x808, 0x1, 0x0, 0x0, 0x0, 0x800, 0x801, 0x201, 0x801, 0x801, 0x801, 0x801, 0x201, 0x4, 0x0, 0x100, 0x808, 0xFFF, 0x801, 0x801, 0xFFF, 0x801, 0x801, 0x3F1, 0x801, 0x801, 0x801, 0x801, 0xFF1, 0xFC7, 0xFFF, 0xF1F, 0x8FF, 0x101, 0x0, 0x0, 0x0, 0x800, 0x801, 0x201, 0x801, 0x801, 0x801, 0x801, 0x201, 0x4, 0x0, 0x100, 0x808, 0x101, 0x0, 0x0, 0x0, 0x800, 0x801, 0x201, 0x801, 0x801, 0x801, 0x801, 0x201, 0x4, 0x0, 0x100, 0x808, 0x101, 0x0, 0x0, 0x0, 0x800, 0x801, 0x201, 0x801, 0x801, 0x801, 0x801, 0x201, 0x4, 0x0, 0x100, 0x808, 0xFF1, 0xF1F, 0xF1F, 0xFFF, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xFFF, 0xFC3, 0xE1F, 0xFFF, 0xFFF, 0xFFF, 0xE3F, 0xFF1, 0xF1F, 0xF1F, 0xFFF, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xFFF, 0xFC3, 0xE1F, 0xFFF, 0xFFF, 0xFFF, 0xE3F, 0x111, 0x801, 0xB01, 0x24, 0x0, 0x400, 0x2, 0x0, 0x0, 0x0, 0x800, 0x1, 0x800, 0x801, 0x24, 0x820, 0x111, 0x801, 0xE01, 0x24, 0x0, 0x400, 0x2, 0x0, 0x0, 0x0, 0x800, 0x1, 0x800, 0x801, 0x24, 0x820, 0xF11, 0x801, 0xC01, 0xC3F, 0xC03, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0x801, 0xFFF, 0x8F1, 0x801, 0x87F, 0x83F, 0x111, 0x801, 0x801, 0x4, 0x0, 0x400, 0x2, 0x0, 0x0, 0x0, 0x800, 0x1, 0x800, 0x801, 0x4, 0x800, 0x111, 0x801, 0x801, 0x4, 0x0, 0x400, 0x2, 0x0, 0x0, 0x0, 0x800, 0x1, 0x800, 0x801, 0x4, 0x800, 0x111, 0x801, 0x801, 0x4, 0x0, 0x400, 0x2, 0x0, 0x0, 0x0, 0x800, 0x1, 0x800, 0x801, 0x4, 0x800, 0xFF1, 0xF1F, 0xF1F, 0xFC7, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xF1F, 0xE1F, 0xFFF, 0xFF1, 0xF1F, 0xF1F, 0xFC7, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xF1F, 0xE1F, 0xFFF, 0x211, 0x4, 0x200, 0x801, 0x201, 0xE04, 0x401, 0x801, 0x801, 0x801, 0x4, 0x200, 0x801, 0x401, 0x2, 0x800, 0x211, 0x4, 0x200, 0x801, 0x201, 0xC04, 0x401, 0x801, 0x801, 0x801, 0x4, 0x200, 0x801, 0x401, 0x2, 0x800, 0xE11, 0xF07, 0xE3F, 0x801, 0xFF1, 0x807, 0xFF1, 0x801, 0x801, 0x801, 0xFFF, 0xFFF, 0x801, 0xFE1, 0xFC3, 0x81F, 0x211, 0x4, 0x200, 0x801, 0x201, 0x804, 0x401, 0x801, 0x801, 0x801, 0x4, 0x200, 0x801, 0x401, 0x2, 0x800, 0x211, 0x4, 0x200, 0x801, 0x201, 0x804, 0x401, 0x801, 0x801, 0x801, 0x4, 0x200, 0x801, 0x401, 0x2, 0x800, 0x211, 0x4, 0x200, 0x801, 0x201, 0x804, 0x401, 0x801, 0x801, 0x801, 0x4, 0x200, 0x801, 0x401, 0x2, 0x800, 0xFF1, 0xFFF, 0xFFF, 0xFFF, 0xF0F, 0xE1F, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xF0F, 0xF0F, 0xF1F, 0xFFF, 0xC3F, 0xFF1, 0xFFF, 0xFFF, 0xFFF, 0xF0F, 0xE1F, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xF0F, 0xF0F, 0xF1F, 0xFFF, 0xC3F, 0x1, 0x400, 0x2, 0x0, 0x800, 0x801, 0x1, 0x400, 0x2, 0x200, 0x101, 0x0, 0x100, 0x0, 0x0, 0x800, 0x1, 0x400, 0x2, 0x0, 0x800, 0x801, 0x1, 0x400, 0x2, 0x200, 0x101, 0x0, 0x100, 0x0, 0x0, 0x800, 0xFFF, 0xC3F, 0x8E3, 0xFFF, 0x87F, 0x801, 0xFE1, 0xFFF, 0xFC3, 0xE1F, 0xFF1, 0x801, 0xFFF, 0x801, 0xFFF, 0x87F, 0x41, 0x400, 0x2, 0x0, 0x800, 0x801, 0x1, 0x400, 0x2, 0x200, 0x101, 0x0, 0x100, 0x0, 0x0, 0x800, 0x41, 0x400, 0x2, 0x0, 0x800, 0x801, 0x1, 0x400, 0x2, 0x200, 0x101, 0x0, 0x100, 0x0, 0x0, 0x800, 0x41, 0x400, 0x2, 0x0, 0x800, 0x801, 0x1, 0x400, 0x2, 0x200, 0x101, 0x0, 0x100, 0x0, 0x0, 0x800, 0xFF1, 0xF0F, 0xF0F, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xF0F, 0xF1F, 0xFFF, 0xF0F, 0xF0F, 0xF0F, 0xF1F, 0xFFF, 0xC3F, 0xFF1, 0xF0F, 0xF0F, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xF0F, 0xF1F, 0xFFF, 0xF0F, 0xF0F, 0xF0F, 0xF1F, 0xFFF, 0xC3F, 0x1, 0x0, 0x800, 0x801, 0x4, 0x0, 0x200, 0x4, 0x200, 0x1, 0x200, 0x801, 0xE04, 0xE04, 0x4, 0x800, 0x1, 0x0, 0x800, 0x801, 0x4, 0x0, 0x200, 0x4, 0x200, 0x1, 0x200, 0x801, 0xC04, 0xC04, 0x4, 0x800, 0xFE1, 0x801, 0x801, 0x801, 0x8FF, 0xFFF, 0xE3F, 0xFFF, 0xE3F, 0x8F1, 0xFFF, 0x801, 0x807, 0x807, 0x8FF, 0x83F, 0x1, 0x0, 0x800, 0x801, 0x4, 0x0, 0x200, 0x4, 0x200, 0x1, 0x200, 0x801, 0x804, 0x804, 0x4, 0x800, 0x1, 0x0, 0x800, 0x801, 0x4, 0x0, 0x200, 0x4, 0x200, 0x1, 0x200, 0x801, 0x804, 0x804, 0x4, 0x800, 0x1, 0x0, 0x800, 0x801, 0x4, 0x0, 0x200, 0x4, 0x200, 0x1, 0x200, 0x801, 0x804, 0xE04, 0x4, 0x800, 0xFF1, 0xF0F, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF1F, 0xF0F, 0xC3F, 0xFF1, 0xF0F, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF1F, 0xF0F, 0xC3F, 0x211, 0xE04, 0x801, 0x801, 0x4, 0x400, 0x2, 0x0, 0x0, 0x800, 0x4, 0x0, 0x400, 0x401, 0xE02, 0x802, 0x211, 0xC04, 0x801, 0x801, 0x4, 0x400, 0x2, 0x0, 0x0, 0x800, 0x4, 0x0, 0x400, 0x401, 0xC02, 0x802, 0xE11, 0x807, 0x801, 0x801, 0xFC7, 0xC7F, 0xFE3, 0x807, 0xFFF, 0x8F1, 0xFFF, 0xFFF, 0xC7F, 0xFF1, 0x803, 0x83F, 0x211, 0x804, 0x801, 0x801, 0x4, 0x400, 0x2, 0x4, 0x0, 0x800, 0x4, 0x0, 0x400, 0x401, 0x802, 0x802, 0x211, 0xC04, 0x801, 0x801, 0x4, 0x400, 0x2, 0x4, 0x0, 0x800, 0x4, 0x0, 0x400, 0x401, 0x802, 0x802, 0x211, 0xE04, 0x801, 0x801, 0x4, 0x400, 0x2, 0x4, 0x0, 0x800, 0x4, 0x0, 0x400, 0x401, 0x802, 0x803, 0xFF1, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xFFF, 0xFFF, 0xF0F, 0xFFF, 0xFFF, 0xF1F, 0xF0F, 0xC3F, 0xFF1, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xFFF, 0xFFF, 0xF0F, 0xFFF, 0xFFF, 0xF1F, 0xF0F, 0xC3F, 0x811, 0x801, 0x801, 0x201, 0x801, 0x2, 0x400, 0x801, 0x2, 0x400, 0x401, 0x2, 0x0, 0x400, 0x201, 0x804, 0x811, 0x801, 0x801, 0x201, 0x801, 0x2, 0x400, 0x801, 0x2, 0x400, 0x401, 0x2, 0x0, 0x400, 0x201, 0x804, 0x811, 0x801, 0x801, 0xFF1, 0x801, 0xFE3, 0xC7F, 0x801, 0x8E3, 0xC3F, 0xFF1, 0xFFF, 0xFFF, 0xC7F, 0xFF1, 0x8FF, 0xFF1, 0x801, 0x801, 0x201, 0x801, 0x2, 0x400, 0x801, 0x2, 0x400, 0x401, 0x2, 0x0, 0x400, 0x201, 0x804, 0x801, 0x801, 0x801, 0x201, 0x801, 0x2, 0x400, 0x801, 0x2, 0x400, 0x401, 0x2, 0x0, 0x400, 0x201, 0x804, 0x801, 0x801, 0x801, 0x201, 0x801, 0x2, 0x400, 0x801, 0x2, 0x400, 0x401, 0x2, 0x0, 0x400, 0x201, 0x804, 0xF0F, 0xFFF, 0xFFF, 0xF0F, 0xFC3, 0xFFF, 0xF0F, 0xFFF, 0xE1F, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xFFF, 0xF0F, 0xE1F, 0xF0F, 0xFFF, 0xFFF, 0xF0F, 0xFC3, 0xFFF, 0xF0F, 0xFFF, 0xE1F, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xFFF, 0xF0F, 0xE1F, 0x1, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x808, 0x1, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x808, 0xFE1, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0x87F, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x800, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x800, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x800, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF };

/////////////////////////
// Setup and Main loop //
/////////////////////////
void setup()
{
  arduboy.begin();
  arduboy.setFrameRate(30);
  arduboy.initRandomSeed();

  // Initialize scores in EEPROM - uncomment only if you want to reset your scores!
  //SaveHiscore(0, 0);

  FetchHiscore();
}

void loop()
{
  if (!(arduboy.nextFrame()))
    return;

  switch (gameState)
  {
    case STATE_MENU_MAIN:
      DisplayMainMenu();
      break;

    case STATE_MENU_PLAY:
      GamePlayInit();
      break;

    case STATE_GAME_PLAYING:
      GamePlaying();
      break;

    case STATE_GAME_OVER:
      DisplayGameOver();
      break;

    case STATE_GAME_WON:
      DisplayGameWon();
      break;

    case STATE_PAUSED:
      DisplayPausedGame();
      break;
  }

  arduboy.display();
}

/////////////////////////////////
// Code besides 2 main methods //
/////////////////////////////////

void DisplayMainMenu()
{
  arduboy.clear();

  if (arduboy.everyXFrames(25))
  {
    if (mainFrame == 0)
      mainFrame = 1;
    else
      mainFrame = 0;
  }

  arduboy.fillRect(0, 0, 128, 36, 0);
        
  if (mainFrame == 0)
    arduboy.drawBitmap(0, 0, img1Main, 128, 36, 1);
  else
    arduboy.drawBitmap(0, 0, img2Main, 128, 36, 1);

  arduboy.setCursor(12, 39);
  arduboy.print("Hiscore");

  arduboy.setCursor(5, 51);
  PrintScore(hiscore);

  DrawPct(pctHiscore, 36, 51);

  arduboy.setCursor(70, 45);
  arduboy.print("'B' Play");

  arduboy.drawLine(0, 36, 0, 63, 1);
  arduboy.drawLine(1, 36, 1, 63, 1);

  arduboy.drawLine(62, 36, 62, 63, 1);
  arduboy.drawLine(63, 36, 63, 63, 1);

  arduboy.drawLine(126, 36, 126, 63, 1);
  arduboy.drawLine(127, 36, 127, 63, 1);

  arduboy.drawLine(0, 62, 127, 62, 1);
  arduboy.drawLine(0, 63, 127, 63, 1);

  if (arduboy.pressed(UP_BUTTON) && arduboy.pressed(DOWN_BUTTON))
    cheat = true;
  else if (arduboy.pressed(B_BUTTON))
    gameState = STATE_MENU_PLAY;
}

void DisplayGameOver()
{
  arduboy.clear();

  arduboy.setTextSize(2);
  arduboy.setCursor(12, 0);
  arduboy.print("GAME OVER");

  arduboy.setTextSize(1);
  arduboy.setCursor(42, 23);
  arduboy.print("SCORE");
  arduboy.setCursor(80, 23);
  PrintScore(CalcScore(score));

  arduboy.setCursor(24, 33);
  arduboy.print("PROGRESS");
  DrawPct(pct, 86, 33);

  arduboy.setCursor(12, 43);
  arduboy.print("KILL COUNT");
  arduboy.setCursor(80, 43);
  PrintScore(totalKillCounter);

  if (newHiscore)
  {
    if (arduboy.everyXFrames(20))
    {
      if (prFrame == 0)
        prFrame = 1;
      else
        prFrame = 0;
    }

    if (prFrame == 1)
    {
      arduboy.setCursor(115, 23);
      arduboy.print("PR");
    }
  }
  
  arduboy.setCursor(0, 57);
  arduboy.print("Press 'LEFT' for menu");

  if (arduboy.pressed(LEFT_BUTTON) || arduboy.pressed(RIGHT_BUTTON) || arduboy.pressed(UP_BUTTON) || arduboy.pressed(DOWN_BUTTON))
    gameState = STATE_MENU_MAIN;
}

void DisplayGameWon()
{
  arduboy.clear();

  arduboy.setTextSize(2);
  arduboy.setCursor(12, 0);
  arduboy.print("YOU WON!");

  arduboy.setTextSize(1);
  arduboy.setCursor(42, 23);
  arduboy.print("SCORE");
  arduboy.setCursor(80, 23);
  PrintScore(CalcScore(score));

  arduboy.setCursor(24, 33);
  arduboy.print("PROGRESS");
  DrawPct(pct, 86, 33);

  arduboy.setCursor(12, 43);
  arduboy.print("KILL COUNT");
  arduboy.setCursor(80, 43);
  PrintScore(totalKillCounter);

  if (newHiscore)
  {
    if (arduboy.everyXFrames(20))
    {
      if (prFrame == 0)
        prFrame = 1;
      else
        prFrame = 0;
    }

    if (prFrame == 1)
    {
      arduboy.setCursor(115, 23);
      arduboy.print("PR");
    }
  }
    
  arduboy.setCursor(10, 57);
  arduboy.print("Press 'A' for menu");

  if (arduboy.pressed(A_BUTTON))
    gameState = STATE_MENU_MAIN;
}

void DisplayPausedGame()
{
  arduboy.clear();

  arduboy.setTextSize(2);
  arduboy.setCursor(4, 2);
  arduboy.print("GAME PAUSE");

  arduboy.setTextSize(1);
  arduboy.setCursor(32, 27);
  arduboy.print("Score");
  arduboy.setCursor(70, 27);
  PrintScore(CalcScore(score));

  arduboy.setCursor(14, 40);
  arduboy.print("Progress");
  DrawPct(pct, 76, 40);

  arduboy.setCursor(10, 54);
  arduboy.print("Press 'B' for game");

  if (arduboy.pressed(B_BUTTON))
  {
    gameState = STATE_GAME_PLAYING;
    RoomChange();
  }
}

void GamePlayInit()
{
  roomX            = 8;
  roomY            = 10; 
  score            = 0;
  avatarY          = 28;
  avatarX          = 44;
  lives            = MAX_LIVES;
  currentNumGhosts = 0;
  fencingGauge     = 0;
  potionLevel      = 0;
  newHiscore       = false;

  arduboy.clear();

  InitKeys();
  SetNumberOfGhosts();
  RoomChange();
  InitPctBits();

  if (soundYes == true)
    arduboy.audio.on();
  else
    arduboy.audio.off();

  gameState = STATE_GAME_PLAYING;
}

void GamePlaying()
{
  if (potionLevel > 0)
    potionLevel--;
  
  UnDrawGhosts();
  GhostsMovement();
      
  CheckFindKeys();

  UnDrawAvatar();
      
  if (arduboy.pressed(LEFT_BUTTON))
  {
    facingRight = false;

    if (avatarX <= 0)
    {
      roomX--;
      avatarX = SCREEN_WIDTH - AVATAR_WIDTH;
      RoomChange();
    }

    if (!WallCollision(avatarX - AVATAR_STEP_CHANGE, avatarY, "L"))
      avatarX -= AVATAR_STEP_CHANGE;

    avatarDirection = DIRECTION_LEFT;
  }
  else if (arduboy.pressed(RIGHT_BUTTON))
  {
    facingRight = true;

    if (avatarX >= SCREEN_WIDTH - AVATAR_WIDTH)
    {
      roomX++;
      avatarX = 0;
      RoomChange();
    }

    if (!WallCollision(avatarX + AVATAR_STEP_CHANGE, avatarY, "R"))
      avatarX += AVATAR_STEP_CHANGE;

    avatarDirection = DIRECTION_RIGHT;
  }
  else if (arduboy.pressed(DOWN_BUTTON))
  {
    if (avatarY >= SCREEN_HEIGHT - AVATAR_HEIGHT)
    {
      roomY++;
      avatarY = 0;
      RoomChange();
    }

    if (!WallCollision(avatarX, avatarY + AVATAR_STEP_CHANGE, "D"))
      avatarY += AVATAR_STEP_CHANGE;

    avatarDirection = DIRECTION_DOWN;
  }
  else if (arduboy.pressed(UP_BUTTON))
  {
    if (avatarY <= 0)
    {
      roomY--;
      avatarY = SCREEN_HEIGHT - AVATAR_HEIGHT;
      RoomChange();
    }

    if (!WallCollision(avatarX, avatarY - AVATAR_STEP_CHANGE, "U"))
      avatarY -= AVATAR_STEP_CHANGE;

    avatarDirection = DIRECTION_UP;
  }

  if (arduboy.pressed(A_BUTTON + B_BUTTON)) // Main menu
    gameState = STATE_MENU_MAIN;

  if (arduboy.pressed(A_BUTTON)) // Paused game
    gameState = STATE_PAUSED;

  if (arduboy.pressed(B_BUTTON)) // fencing
  {
    if (fencingGauge < 300)
    {
      fencingGauge++;

      if (fencingGauge < 255)
        fencing = true;
      else
        fencing = false;
    }
    else
      fencing = false;
  }
  else
    fencing = false;
  
  if (!fencing && fencingGauge > 0)
    fencingGauge--;

  CollisionAvatarAndItems();

  if (CollisionAvatarAndGhosts())
  {
    byte ghostNo = AvatarKillingGhost();
    
    if (ghostNo != NO_GHOST)
      GhostHit(ghostNo);
    else
    {
      potionLevel = 0;
      AvatarHit();
    }
  }

  SetNumberOfGhosts();
    
  BuildScreen();

  if (ExitFound())
  {
    SetHiscore();
    gameState = STATE_GAME_WON;
  }
  else if (GameOver())
  {
    SetHiscore();
    DrawGameOverScreen();
    gameState = STATE_GAME_OVER;
  }
}

void SetNumberOfGhosts()
{
  byte tempCurrNumGhosts = currentNumGhosts;
  
  if (pct < 20)
    currentNumGhosts = 1;
  else if (pct >= 20 && pct < 40)
    currentNumGhosts = 2;
  else if (pct >= 40 && pct < 60)
    currentNumGhosts = 3;
  else if (pct >= 60 && pct < 80)
    currentNumGhosts = 4;
  else if (pct >= 80)
    currentNumGhosts = 5;

  if (currentNumGhosts != tempCurrNumGhosts)
    RoomChange();
}

void GhostHit(byte killedGhostNo)
{
  killCounter++;
  totalKillCounter++;

  if (killCounter > EXTRA_LIFE_KILL)
  {
    killCounter = 0;
    lives++;
  }
  
  if (ghosts[killedGhostNo][GHOST_TYPE] == GHOST_TYPE_SKULL)
    score += SKULL_KILL_SCORE;
  else
    score += GHOST_KILL_SCORE;
    
  DrawScores();
  DrawAvatar(false);
  DrawGhosts();

  // Draw 1 kill sprite + delay
  UnDrawGhost(killedGhostNo);
  arduboy.drawBitmap(ghosts[killedGhostNo][GHOST_X], ghosts[killedGhostNo][GHOST_Y], enemyKill1Img, 8, 8, 1);
  arduboy.display();
  delay(100);

  // Draw 2 kill sprite + delay
  UnDrawGhost(killedGhostNo);
  arduboy.drawBitmap(ghosts[killedGhostNo][GHOST_X], ghosts[killedGhostNo][GHOST_Y], enemyKill2Img, 8, 8, 1);
  arduboy.display();
  delay(100);

  // Remove ghost killed ghost
  UnDrawGhost(killedGhostNo);
  ghosts[killedGhostNo][GHOST_X]    = NO_GHOST;
  ghosts[killedGhostNo][GHOST_Y]    = NO_GHOST;
  ghosts[killedGhostNo][GHOST_TYPE] = NO_GHOST;
  
  arduboy.display();
}

void AvatarHit()
{
  lives--;
  
  DrawLives();
  DrawAvatar(true);
  arduboy.display();
  delay(1000);
  
  UnDrawGhosts();
  NoGhosts(); // remove ghosts, to avoid quickly death!
  delay(1000);

  DrawAvatar(false);
}

boolean GameOver()
{
  if (lives == 0)
    return true;
  else
    return false;
}

boolean ExitFound()
{
  if (roomX == 8 && roomY == 8 && avatarX > 32 && avatarX < 57 && avatarY > 20 && avatarY < 32)
    return true;
  else
    return false;
}

void SetHiscore()
{
  unsigned int fullScore = CalcScore(score);
  if (fullScore > hiscore)
  {
    hiscore    = fullScore;
    pctHiscore = pct;
    SaveHiscore(hiscore, pctHiscore);
    newHiscore = true;
  }  
}

/////////////////////
// Screen handling //
/////////////////////
void BuildScreen()
{
  DrawScores();
  DrawAvatar(false);
  DrawGhosts();
  DrawItems();
  DrawKey();
  DrawExit();
}

void DrawWalls()
{
  for (byte b = 0; b < numberBitMaps; b++)
  {
    if (roomBitMaps[b][BITMAP_X] != BITMAP_NODATA && roomBitMaps[b][BITMAP_Y] != BITMAP_NODATA)
    {
      if (roomY == 0 && roomBitMaps[b][BITMAP_Y] == 0)
        arduboy.drawBitmap(roomBitMaps[b][BITMAP_X], roomBitMaps[b][BITMAP_Y], outerWallImg, 8, 8, 1);
      else if (roomY == MAX_ROOM_Y - 1 && roomBitMaps[b][BITMAP_Y] == 56)
        arduboy.drawBitmap(roomBitMaps[b][BITMAP_X], roomBitMaps[b][BITMAP_Y], outerWallImg, 8, 8, 1);
      else if (roomX == 0 && roomBitMaps[b][BITMAP_X] == 0)
        arduboy.drawBitmap(roomBitMaps[b][BITMAP_X], roomBitMaps[b][BITMAP_Y], outerWallImg, 8, 8, 1);
      else if (roomX == MAX_ROOM_X - 1 && roomBitMaps[b][BITMAP_X] == 88)
        arduboy.drawBitmap(roomBitMaps[b][BITMAP_X], roomBitMaps[b][BITMAP_Y], outerWallImg, 8, 8, 1);
      else if ((roomX == 7 || roomX == 8 || roomX == 9) && roomY == 8)
        arduboy.drawBitmap(roomBitMaps[b][BITMAP_X], roomBitMaps[b][BITMAP_Y], exitRoomWallImg, 8, 8, 1);
      else if (roomX == 7 && roomY == 7 && (roomBitMaps[b][BITMAP_X] == 32 || roomBitMaps[b][BITMAP_X] == 40 || roomBitMaps[b][BITMAP_X] == 48 || roomBitMaps[b][BITMAP_X] == 56) && roomBitMaps[b][BITMAP_Y] == 56)
        arduboy.drawBitmap(roomBitMaps[b][BITMAP_X], roomBitMaps[b][BITMAP_Y], fenceImg, 8, 8, 1);
      else if (roomX == 8 && roomY == 9 && (roomBitMaps[b][BITMAP_X] == 32 || roomBitMaps[b][BITMAP_X] == 40 || roomBitMaps[b][BITMAP_X] == 48 || roomBitMaps[b][BITMAP_X] == 56) && roomBitMaps[b][BITMAP_Y] == 0)
        arduboy.drawBitmap(roomBitMaps[b][BITMAP_X], roomBitMaps[b][BITMAP_Y], fenceImg, 8, 8, 1);
      else if (roomX == 9 && roomY == 7 && (roomBitMaps[b][BITMAP_X] == 32 || roomBitMaps[b][BITMAP_X] == 40 || roomBitMaps[b][BITMAP_X] == 48 || roomBitMaps[b][BITMAP_X] == 56) && roomBitMaps[b][BITMAP_Y] == 56)
        arduboy.drawBitmap(roomBitMaps[b][BITMAP_X], roomBitMaps[b][BITMAP_Y], fenceImg, 8, 8, 1);
      else
        arduboy.drawBitmap(roomBitMaps[b][BITMAP_X], roomBitMaps[b][BITMAP_Y], innerWallImg, 8, 8, 1);
    }
  }
}

void DrawScores()
{
  arduboy.setTextSize(1);

  arduboy.setCursor(98, 10);
  PrintScore(CalcScore(score));

  if (cheat)
  {
    arduboy.setCursor(98, 0);
    if (roomX < 10)
      arduboy.print("0" + String(roomX) + ",");
    else
      arduboy.print(String(roomX) + ",");

    arduboy.setCursor(116, 0);
    if (roomY < 10)
      arduboy.print("0" + String(roomY));
    else
      arduboy.print(String(roomY));
  }

  arduboy.setCursor(98, 22);
  arduboy.print(String(CountFoundKeys()) + " / 4");

  DrawLives();

  DrawPct(pct, 102, 48);

  DrawFencingGauge();
}

void DrawFixedScores()
{
  arduboy.setTextSize(1);

  arduboy.setCursor(98, 0);
  arduboy.print("Score");

  arduboy.drawLine(98, 59, 127, 59, 1);
  arduboy.drawLine(98, 63, 127, 63, 1);
  arduboy.drawLine(98, 59, 98, 63, 1);
  arduboy.drawLine(127, 59, 127, 63, 1);
}

void DrawFencingGauge()
{
  unsigned int gauge = fencingGauge / 10;

  if (gauge > 25)
    gauge = 25;

  // Remove gauge
  arduboy.drawLine(100, 61, 125, 61, 0);
  
  if (gauge > 0)
    arduboy.drawLine(100, 61, 100 + gauge, 61, 1);
}

void DrawLives()
{
  // Undraw lives
  arduboy.fillRect(98, 34, 30, 8, 0);

  // Heart 1
  if (lives > 1)
    arduboy.drawBitmap(98, 34, heartImgFull, 8, 8, 1);
  else if (lives == 1)
    arduboy.drawBitmap(98, 34, heartImgEmpty, 8, 8, 1);

  // Heart 2
  if (lives > 3)
    arduboy.drawBitmap(107, 34, heartImgFull, 8, 8, 1);
  else if (lives == 3)
    arduboy.drawBitmap(107, 34, heartImgEmpty, 8, 8, 1);

  // Heart 3
  if (lives > 5)
    arduboy.drawBitmap(116, 34, heartImgFull, 8, 8, 1);
  else if (lives == 5)
    arduboy.drawBitmap(116, 34, heartImgEmpty, 8, 8, 1);

  // Extra lives
  if (lives > 6)
    arduboy.drawBitmap(125, 34, heartImgExtra, 3, 8, 1);
}

void DrawPct(byte pctValue, byte x, byte y)
{
  arduboy.setCursor(x, y);
  if (pctValue <= 9)
    arduboy.print("  " + String(pctValue) + "%");
  else if (pctValue <= 99)
    arduboy.print(" " + String(pctValue) + "%");
  else
    arduboy.print(String(pctValue) + "%");
}

unsigned int CalcScore(unsigned int score)
{
  return score + (pct * PCT_SCORE);
}

void PrintScore(unsigned int value)
{
  if (value < 10)
    arduboy.print("0000" + String(value));
  else if (value < 100)
    arduboy.print("000" + String(value));
  else if (value < 1000)
    arduboy.print("00" + String(value));
  else if (value < 10000)
    arduboy.print("0" + String(value));
  else
    arduboy.print("" + String(value));
}

void DrawAvatar(boolean lostLive)
{
  if (arduboy.everyXFrames(4) && (arduboy.pressed(LEFT_BUTTON) || arduboy.pressed(RIGHT_BUTTON) || arduboy.pressed(UP_BUTTON) || arduboy.pressed(DOWN_BUTTON)))
  {
    if (potionLevel == 0)
    {
      if (avatarFrame == 0)
        avatarFrame = 1;
      else
        avatarFrame = 0;
    }
    else
    {
      if (avatarFrame == 0)
        avatarFrame = 2;
      else
        avatarFrame = 0;
    }
  }
  else if (arduboy.everyXFrames(4) && potionLevel > 0)
  {
    if (avatarFrame == 0)
      avatarFrame = 4;
    else
      avatarFrame = 0;
  }
  else if (avatarFrame == 2)
      avatarFrame == 0;
  
  if (facingRight)
  {
    if (lostLive)
      arduboy.drawBitmap(avatarX, avatarY, avatarRightFallImg, AVATAR_WIDTH, AVATAR_HEIGHT, 1);
    else if (avatarFrame == 0)
    {
      if (fencing)
        arduboy.drawBitmap(avatarX, avatarY, avatarRight1fencingImg, AVATAR_WIDTH, AVATAR_HEIGHT, 1);
      else
        arduboy.drawBitmap(avatarX, avatarY, avatarRight1Img, AVATAR_WIDTH, AVATAR_HEIGHT, 1);
    }
    else if (avatarFrame == 1)
    {
      if (fencing)
        arduboy.drawBitmap(avatarX, avatarY, avatarRight2fencingImg, AVATAR_WIDTH, AVATAR_HEIGHT, 1);
      else
        arduboy.drawBitmap(avatarX, avatarY, avatarRight2Img, AVATAR_WIDTH, AVATAR_HEIGHT, 1);
    }
    else
      arduboy.fillRect(avatarX, avatarY, AVATAR_WIDTH, AVATAR_HEIGHT, 0);
  }
  else
  {
    if (lostLive)
      arduboy.drawBitmap(avatarX, avatarY, avatarLeftFallImg, AVATAR_WIDTH, AVATAR_HEIGHT, 1);
    else if (avatarFrame == 0)
    {
      if (fencing)
        arduboy.drawBitmap(avatarX, avatarY, avatarLeft1fencingImg, AVATAR_WIDTH, AVATAR_HEIGHT, 1);
      else
        arduboy.drawBitmap(avatarX, avatarY, avatarLeft1Img, AVATAR_WIDTH, AVATAR_HEIGHT, 1);
    }
    else if (avatarFrame == 1)
    {
      if (fencing)
        arduboy.drawBitmap(avatarX, avatarY, avatarLeft2fencingImg, AVATAR_WIDTH, AVATAR_HEIGHT, 1);
      else
        arduboy.drawBitmap(avatarX, avatarY, avatarLeft2Img, AVATAR_WIDTH, AVATAR_HEIGHT, 1);
    }
    else
      arduboy.fillRect(avatarX, avatarY, AVATAR_WIDTH, AVATAR_HEIGHT, 0);
  }
}

void UnDrawAvatar()
{
  arduboy.fillRect(avatarX, avatarY, AVATAR_WIDTH, AVATAR_HEIGHT, 0);
}

void DrawItems()
{
  for (byte i = 0; i < MAX_NUM_OF_ITEM; i++)
  {
    if (items[i][ITEM_X] != NO_ITEM && items[i][ITEM_X] != NO_ITEM)
    {
      if (items[i][ITEM_TYPE] == ITEM_HEART)
      {
        if (arduboy.everyXFrames(15))
        {
          if (heartFrame == 0)
            heartFrame = 1;
          else
            heartFrame = 0;
        }

        arduboy.fillRect(items[i][ITEM_X], items[i][ITEM_Y], ITEM_WIDTH, ITEM_HEIGHT, 0);
        
        if (heartFrame == 0)
          arduboy.drawBitmap(items[i][ITEM_X], items[i][ITEM_Y], heartImgSmall, 8, 8, 1);
        else
          arduboy.drawBitmap(items[i][ITEM_X], items[i][ITEM_Y], heartImgFull, 8, 8, 1);
      }
      else if (items[i][ITEM_TYPE] == ITEM_FLOWER)
        arduboy.drawBitmap(items[i][ITEM_X], items[i][ITEM_Y], flowerImg, 8, 8, 1);
      else if (items[i][ITEM_TYPE] == ITEM_APPLE)
        arduboy.drawBitmap(items[i][ITEM_X], items[i][ITEM_Y], appleImg, 8, 8, 1);
      else if (items[i][ITEM_TYPE] == ITEM_COFFEE)
      {
        if (arduboy.everyXFrames(8))
        {
          if (coffeeFrame == 0)
            coffeeFrame = 1;
          else
            coffeeFrame = 0;
        }

        arduboy.fillRect(items[i][ITEM_X], items[i][ITEM_Y], ITEM_WIDTH, ITEM_HEIGHT, 0);
        
        if (coffeeFrame == 0)
          arduboy.drawBitmap(items[i][ITEM_X], items[i][ITEM_Y], coffee1Img, 8, 8, 1);
        else
          arduboy.drawBitmap(items[i][ITEM_X], items[i][ITEM_Y], coffee2Img, 8, 8, 1);
      }
      else if (items[i][ITEM_TYPE] == ITEM_POTION)
      {
        if (arduboy.everyXFrames(25))
        {
          if (potionFrame == 0)
            potionFrame = 1;
          else
            potionFrame = 0;
        }

        arduboy.fillRect(items[i][ITEM_X], items[i][ITEM_Y], ITEM_WIDTH, ITEM_HEIGHT, 0);
        
        if (potionFrame == 0)
          arduboy.drawBitmap(items[i][ITEM_X], items[i][ITEM_Y], potion1Img, 8, 8, 1);
        else
          arduboy.drawBitmap(items[i][ITEM_X], items[i][ITEM_Y], potion2Img, 8, 8, 1);
      }
      else if (items[i][ITEM_TYPE] == ITEM_GRASS)
        arduboy.drawBitmap(items[i][ITEM_X], items[i][ITEM_Y], grassImg, 8, 8, 1);
    }
  }  
}

void UnDrawItem(byte itemNum)
{
  if (items[itemNum][ITEM_X] != NO_ITEM && items[itemNum][ITEM_X] != NO_ITEM)
    arduboy.fillRect(items[itemNum][ITEM_X], items[itemNum][ITEM_Y], ITEM_WIDTH, ITEM_HEIGHT, 0);
}

void DrawGhosts()
{
  for (byte g = 0; g < currentNumGhosts; g++)
  {
    if (ghosts[g][GHOST_X] != NO_GHOST && ghosts[g][GHOST_Y] != NO_GHOST)
    {
      if (ghosts[g][GHOST_TYPE] == GHOST_TYPE_GHOST1)
        arduboy.drawBitmap(ghosts[g][GHOST_X], ghosts[g][GHOST_Y], ghost1FullImg, GHOST_WIDTH, GHOST_HEIGHT, 1);
      else if (ghosts[g][GHOST_TYPE] == GHOST_TYPE_GHOST2)
        arduboy.drawBitmap(ghosts[g][GHOST_X], ghosts[g][GHOST_Y], ghost2FullImg, GHOST_WIDTH, GHOST_HEIGHT, 1);
      else if (ghosts[g][GHOST_TYPE] == GHOST_TYPE_HEAD)
        arduboy.drawBitmap(ghosts[g][GHOST_X], ghosts[g][GHOST_Y], headFullImg, GHOST_WIDTH, GHOST_HEIGHT, 1);
      else if (ghosts[g][GHOST_TYPE] == GHOST_TYPE_SKULL)
        arduboy.drawBitmap(ghosts[g][GHOST_X], ghosts[g][GHOST_Y], skullFullImg, GHOST_WIDTH, GHOST_HEIGHT, 1);
    }
  }
}

void DrawGhost(byte ghostNumber)
{
  if (ghosts[ghostNumber][GHOST_TYPE] == GHOST_TYPE_GHOST1)
    arduboy.drawBitmap(ghosts[ghostNumber][GHOST_X], ghosts[ghostNumber][GHOST_Y], ghost1FullImg, GHOST_WIDTH, GHOST_HEIGHT, 1);
  else if (ghosts[ghostNumber][GHOST_TYPE] == GHOST_TYPE_GHOST2)
    arduboy.drawBitmap(ghosts[ghostNumber][GHOST_X], ghosts[ghostNumber][GHOST_Y], ghost2FullImg, GHOST_WIDTH, GHOST_HEIGHT, 1);
  else if (ghosts[ghostNumber][GHOST_TYPE] == GHOST_TYPE_HEAD)
    arduboy.drawBitmap(ghosts[ghostNumber][GHOST_X], ghosts[ghostNumber][GHOST_Y], headFullImg, GHOST_WIDTH, GHOST_HEIGHT, 1);
  else if (ghosts[ghostNumber][GHOST_TYPE] == GHOST_TYPE_SKULL)
    arduboy.drawBitmap(ghosts[ghostNumber][GHOST_X], ghosts[ghostNumber][GHOST_Y], skullFullImg, GHOST_WIDTH, GHOST_HEIGHT, 1);
}

void UnDrawGhosts()
{
  for (byte g = 0; g < currentNumGhosts; g++)
  {
    if (ghosts[g][GHOST_X] != NO_GHOST && ghosts[g][GHOST_X] != NO_GHOST)
      arduboy.fillRect(ghosts[g][GHOST_X], ghosts[g][GHOST_Y], GHOST_WIDTH, GHOST_HEIGHT, 0);
  }
}

void UnDrawGhost(byte ghostNumber)
{
  if (ghosts[ghostNumber][GHOST_X] != NO_GHOST && ghosts[ghostNumber][GHOST_Y] != NO_GHOST)
    arduboy.fillRect(ghosts[ghostNumber][GHOST_X], ghosts[ghostNumber][GHOST_Y], GHOST_WIDTH, GHOST_HEIGHT, 0);
}

void DrawExit()
{
  if (roomX == 8 && roomY == 8)
    arduboy.drawBitmap(36, 20, exitImg, EXIT_WIDTH, EXIT_HEIGHT, 1);
}

void DrawGameOverScreen()
{
  UnDrawAvatar();
  for (byte i = 0; i < 2; i++)
  {
    arduboy.drawBitmap(avatarX, avatarY, gameOverImg, 8, 8, 1);
    arduboy.display();
    delay(500);
    
    arduboy.fillRect(avatarX, avatarY, 8, 8, 0);
    arduboy.display();
    delay(500);
  }

  arduboy.drawBitmap(avatarX, avatarY, gameOverImg, 8, 8, 1);
  arduboy.display();
  delay(5000);  
}

//////////////////
// Key handling //
//////////////////
bool FenceOpen()
{
  if (CountFoundKeys() == NO_KEYS)
    return true;
  else
    return false;
}

void InitKeys()
{
  for (int i = 0; i < NO_KEYS; i++)
  {
    keys[i] = false;
  }
}

byte CountFoundKeys()
{
  byte counter = 0;
  for (byte i = 0; i < NO_KEYS; i++)
  {
    if (keys[i] == true)
      counter++;
  }

  return counter;
}

void CheckFindKeys()
{
  if (roomX == 2 && roomY == 14 && avatarX > 40 && avatarX < 56 && avatarY > 24 && avatarY < 40 && keys[0] == false)
  {
    keys[0] = true;
    UnDrawKey();
    score += KEY_SCORE;
  }
  else if (roomX == 7 && roomY == 14 && avatarX > 40 && avatarX < 56 && avatarY > 24 && avatarY < 40 && keys[1] == false)
  {
    keys[1] = true;
    UnDrawKey();
    score += KEY_SCORE;
  }
  else if (roomX == 4 && roomY == 9 && avatarX > 40 && avatarX < 56 && avatarY > 24 && avatarY < 40 && keys[2] == false)
  {
    keys[2] = true;
    UnDrawKey();
    score += KEY_SCORE;
  }
  else if (roomX == 9 && roomY == 3 && avatarX > 40 && avatarX < 56 && avatarY > 24 && avatarY < 40 && keys[3] == false)
  {
    keys[3] = true;
    UnDrawKey();
    score += KEY_SCORE;
  }
}

void DrawKey()
{
  if (roomX == 2 && roomY == 14 && keys[0] == false)
    arduboy.drawBitmap(44, 28, keyImg, KEY_WIDTH, KEY_HEIGHT, 1);
  else if (roomX == 7 && roomY == 14 && keys[1] == false)
    arduboy.drawBitmap(44, 28, keyImg, KEY_WIDTH, KEY_HEIGHT, 1);
  else if (roomX == 4 && roomY == 9 && keys[2] == false)
    arduboy.drawBitmap(44, 28, keyImg, KEY_WIDTH, KEY_HEIGHT, 1);
  else if (roomX == 9 && roomY == 3 && keys[3] == false)
    arduboy.drawBitmap(44, 28, keyImg, KEY_WIDTH, KEY_HEIGHT, 1);
}

void UnDrawKey()
{
  arduboy.fillRect(44, 28, KEY_WIDTH, KEY_HEIGHT, 0);
}

//////////////////
// Map handling //
//////////////////
void InitRoomMap()
{
  for(byte i = 0; i<BITMAPS; i++)
  {
    roomBitMaps[i][BITMAP_X] = BITMAP_NODATA;
    roomBitMaps[i][BITMAP_Y] = BITMAP_NODATA;
  }
}

void BuildRoomMap()
{
  numberBitMaps = 0;

  for (byte y = 0; y < ROOM_SIZE_Y; y++)
  {
    unsigned int pos = (y * MAX_ROOM_X) + roomX + (roomY * MAX_ROOM_X * ROOM_SIZE_Y);
    unsigned int roomLine = pgm_read_word_near(mapBits + pos);

    for (byte x = 0; x < ROOM_SIZE_X; x++)
    {
      if ((roomLine & bits[x]) == bits[x])
      {
        roomBitMaps[numberBitMaps][BITMAP_X] = x * WALL_SIZE_X;
        roomBitMaps[numberBitMaps][BITMAP_Y] = y * WALL_SIZE_Y;

        numberBitMaps++;
      }
    }
  }

  if (roomX == 8 && roomY == 9 && !FenceOpen())
  {
    roomBitMaps[numberBitMaps][BITMAP_X] = 32;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 0;
    numberBitMaps++;
    
    roomBitMaps[numberBitMaps][BITMAP_X] = 40;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 0;
    numberBitMaps++;

    roomBitMaps[numberBitMaps][BITMAP_X] = 48;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 0;
    numberBitMaps++;

    roomBitMaps[numberBitMaps][BITMAP_X] = 56;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 0;
    numberBitMaps++;
  }
  else if (roomX == 7 && roomY == 7 && !FenceOpen())
  {
    roomBitMaps[numberBitMaps][BITMAP_X] = 32;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 56;
    numberBitMaps++;

    roomBitMaps[numberBitMaps][BITMAP_X] = 40;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 56;
    numberBitMaps++;

    roomBitMaps[numberBitMaps][BITMAP_X] = 48;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 56;
    numberBitMaps++;

    roomBitMaps[numberBitMaps][BITMAP_X] = 56;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 56;
    numberBitMaps++;
  }
  else if (roomX == 9 && roomY == 7 && !FenceOpen())
  {
    roomBitMaps[numberBitMaps][BITMAP_X] = 32;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 56;
    numberBitMaps++;

    roomBitMaps[numberBitMaps][BITMAP_X] = 40;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 56;
    numberBitMaps++;

    roomBitMaps[numberBitMaps][BITMAP_X] = 48;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 56;
    numberBitMaps++;

    roomBitMaps[numberBitMaps][BITMAP_X] = 56;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 56;
    numberBitMaps++;
  }
}

boolean GhostCollision(byte ghostNumber, byte ghostXNewPos, byte ghostYNewPos)
{
  for (int g = 0; g < currentNumGhosts; g++)
  {
    if (ghosts[g][GHOST_X] != NO_GHOST && ghosts[g][GHOST_Y] != NO_GHOST && g != ghostNumber)
    {
      int diffX = ghostXNewPos - ghosts[g][GHOST_X];
      int diffY = ghostYNewPos - ghosts[g][GHOST_Y];

      int diffXAbs = abs(diffX);
      int diffYAbs = abs(diffY);

      if (diffXAbs <= GHOST_WIDTH && diffYAbs <= GHOST_HEIGHT)
        return true;
    }
  }
  
  return false;
}

boolean WallCollision(byte avatarNewX, byte avatarNewY, char* dir)
{
  for (byte b = 0; b <= numberBitMaps; b++)
  {
    if (roomBitMaps[b][BITMAP_X] != BITMAP_NODATA && roomBitMaps[b][BITMAP_Y] != BITMAP_NODATA)
    {
      if (dir == "D")
      {
        if ((avatarNewY + AVATAR_HEIGHT >= roomBitMaps[b][BITMAP_Y] && avatarNewY + AVATAR_HEIGHT <= roomBitMaps[b][BITMAP_Y] + WALL_SIZE_Y &&
             avatarNewX >= roomBitMaps[b][BITMAP_X] && avatarNewX <= roomBitMaps[b][BITMAP_X] + WALL_SIZE_X) ||
            (avatarNewY + AVATAR_HEIGHT >= roomBitMaps[b][BITMAP_Y] && avatarNewY + AVATAR_HEIGHT <= roomBitMaps[b][BITMAP_Y] + WALL_SIZE_Y &&
             avatarNewX + AVATAR_WIDTH >= roomBitMaps[b][BITMAP_X] && avatarNewX + AVATAR_WIDTH <= roomBitMaps[b][BITMAP_X] + WALL_SIZE_X))
          return true;
      }
      else if (dir == "U")
      {
        if ((avatarNewY >= roomBitMaps[b][BITMAP_Y] && avatarNewY <= roomBitMaps[b][BITMAP_Y] + WALL_SIZE_Y &&
             avatarNewX >= roomBitMaps[b][BITMAP_X] && avatarNewX <= roomBitMaps[b][BITMAP_X] + WALL_SIZE_X) ||
            (avatarNewY >= roomBitMaps[b][BITMAP_Y] && avatarNewY <= roomBitMaps[b][BITMAP_Y] + WALL_SIZE_Y &&
             avatarNewX + AVATAR_WIDTH >= roomBitMaps[b][BITMAP_X] && avatarNewX + AVATAR_WIDTH <= roomBitMaps[b][BITMAP_X] + WALL_SIZE_X))
          return true;
      }
      else if (dir == "R")
      {
        if ((avatarNewX + AVATAR_WIDTH >= roomBitMaps[b][BITMAP_X] && avatarNewX + AVATAR_WIDTH <= roomBitMaps[b][BITMAP_X] + WALL_SIZE_X &&
             avatarNewY >= roomBitMaps[b][BITMAP_Y] && avatarNewY <= roomBitMaps[b][BITMAP_Y] + WALL_SIZE_Y) ||
            (avatarNewX + AVATAR_WIDTH >= roomBitMaps[b][BITMAP_X] && avatarNewX + AVATAR_WIDTH <= roomBitMaps[b][BITMAP_X] + WALL_SIZE_X &&
             avatarNewY + AVATAR_HEIGHT >= roomBitMaps[b][BITMAP_Y] && avatarNewY + AVATAR_HEIGHT <= roomBitMaps[b][BITMAP_Y] + WALL_SIZE_Y))
          return true;
      }
      else if (dir == "L")
      {
        if ((avatarNewX >= roomBitMaps[b][BITMAP_X] && avatarNewX <= roomBitMaps[b][BITMAP_X] + WALL_SIZE_X &&
             avatarNewY >= roomBitMaps[b][BITMAP_Y] && avatarNewY <= roomBitMaps[b][BITMAP_Y] + WALL_SIZE_Y) ||
            (avatarNewX >= roomBitMaps[b][BITMAP_X] && avatarNewX <= roomBitMaps[b][BITMAP_X] + WALL_SIZE_X &&
             avatarNewY + AVATAR_HEIGHT >= roomBitMaps[b][BITMAP_Y] && avatarNewY + AVATAR_HEIGHT <= roomBitMaps[b][BITMAP_Y] + WALL_SIZE_Y))
          return true;
      }    
    }
  }

  return false;
}

void RoomChange()
{
  arduboy.clear();
  
  InitRoomMap();
  
  AddPctBits(roomX, roomY);
  BuildRoomMap();
  DrawWalls();
  DrawFixedScores();
  AddItems();

  pct = CalcPct();
}

/////////////////////
// Ghosts handling //
/////////////////////
void GhostsMovement()
{
  for (int g = 0; g < currentNumGhosts; g++)
  {
    if (ghosts[g][GHOST_X] != NO_GHOST && ghosts[g][GHOST_Y] != NO_GHOST)
    {
      boolean avatarXNegative = false;
      boolean avatarYNegative = false;
    
      if (avatarX < ghosts[g][GHOST_X])
        avatarXNegative = true;
      else
        avatarXNegative = false;
    
      if (avatarY < ghosts[g][GHOST_Y])
        avatarYNegative = true;
      else
        avatarYNegative = false;

      if (avatarXNegative)
      {
        if (!WallCollision(ghosts[g][GHOST_X] - GHOST_STEP_CHANGE, ghosts[g][GHOST_Y], "L") && 
            !GhostCollision(g, ghosts[g][GHOST_X] - GHOST_STEP_CHANGE, ghosts[g][GHOST_Y]))
          ghosts[g][GHOST_X] = ghosts[g][GHOST_X] - GHOST_STEP_CHANGE;
      }
      else
      {
        if (!WallCollision(ghosts[g][GHOST_X] + GHOST_STEP_CHANGE, ghosts[g][GHOST_Y], "R") &&
            !GhostCollision(g, ghosts[g][GHOST_X] + GHOST_STEP_CHANGE, ghosts[g][GHOST_Y]))
          ghosts[g][GHOST_X] = ghosts[g][GHOST_X] + GHOST_STEP_CHANGE;
      }
    
      if (avatarYNegative)
      {
        if (!WallCollision(ghosts[g][GHOST_X], ghosts[g][GHOST_Y] - GHOST_STEP_CHANGE, "U") &&
            !GhostCollision(g, ghosts[g][GHOST_X], ghosts[g][GHOST_Y] - GHOST_STEP_CHANGE))
          ghosts[g][GHOST_Y] = ghosts[g][GHOST_Y] - GHOST_STEP_CHANGE;
      }
      else
      {
        if (!WallCollision(ghosts[g][GHOST_X], ghosts[g][GHOST_Y] + GHOST_STEP_CHANGE, "D") &&
            !GhostCollision(g, ghosts[g][GHOST_X], ghosts[g][GHOST_Y] + GHOST_STEP_CHANGE))
          ghosts[g][GHOST_Y] = ghosts[g][GHOST_Y] + GHOST_STEP_CHANGE;
      }
    }
  }
}

void NoGhosts()
{
  for (int g = 0; g < currentNumGhosts; g++)
  { 
    ghosts[g][GHOST_X]     = NO_GHOST;
    ghosts[g][GHOST_Y]     = NO_GHOST;
    ghosts[g][GHOST_TYPE]  = NO_GHOST;
  }
}

///////////////////
// Item handling //
///////////////////
void AddItems()
{
  boolean OkPosition = false;
  
  byte randXStart    = 0;
  byte randXEnd      = 0;
  byte randYStart    = 0;
  byte randYEnd      = 0;
  byte randX         = 0;
  byte randY         = 0;
  byte randI         = 0;
  
  currentNumItems    = 0;

  // Flower
  randI = random(1, 3);
  if (randI == 1)
  {
    OkPosition = false;
    while (!OkPosition)
    {
      randXStart =  1;
      randXEnd   = 11;
      randYStart =  1;
      randYEnd   =  7;

      randX = random(randXStart, randXEnd);
      randY = random(randYStart, randYEnd);
        
      OkPosition = OkItemPosition(randX, randY);

      if (OkPosition)
      {
        items[currentNumItems][ITEM_X]    = randX * WALL_SIZE_X;
        items[currentNumItems][ITEM_Y]    = randY * WALL_SIZE_Y;
        items[currentNumItems][ITEM_TYPE] = ITEM_FLOWER;
      }
    }

    currentNumItems++;
  }

  // Apple
  randI = random(1, 4);
  if (randI == 1)
  {
    OkPosition = false;
    while (!OkPosition)
    {
      randXStart =  1;
      randXEnd   = 11;
      randYStart =  1;
      randYEnd   =  7;

      randX = random(randXStart, randXEnd);
      randY = random(randYStart, randYEnd);
        
      OkPosition = OkItemPosition(randX, randY);

      if (OkPosition)
      {
        items[currentNumItems][ITEM_X]    = randX * WALL_SIZE_X;
        items[currentNumItems][ITEM_Y]    = randY * WALL_SIZE_Y;
        items[currentNumItems][ITEM_TYPE] = ITEM_APPLE;
      }
    }

    currentNumItems++;
  }

  // Potion
  randI = random(1, 5);
  if (randI == 1)
  {
    OkPosition = false;
    while (!OkPosition)
    {
      randXStart =  1;
      randXEnd   = 11;
      randYStart =  1;
      randYEnd   =  7;

      randX = random(randXStart, randXEnd);
      randY = random(randYStart, randYEnd);
        
      OkPosition = OkItemPosition(randX, randY);

      if (OkPosition)
      {
        items[currentNumItems][ITEM_X]    = randX * WALL_SIZE_X;
        items[currentNumItems][ITEM_Y]    = randY * WALL_SIZE_Y;
        items[currentNumItems][ITEM_TYPE] = ITEM_POTION;
      }
    }

    currentNumItems++;
  }

  // Heart
  randI = random(1, 7);
  if (randI == 1)
  {
    OkPosition = false;
    while (!OkPosition)
    {
      randXStart =  1;
      randXEnd   = 11;
      randYStart =  1;
      randYEnd   =  7;

      randX = random(randXStart, randXEnd);
      randY = random(randYStart, randYEnd);
        
      OkPosition = OkItemPosition(randX, randY);

      if (OkPosition)
      {
        items[currentNumItems][ITEM_X]    = randX * WALL_SIZE_X;
        items[currentNumItems][ITEM_Y]    = randY * WALL_SIZE_Y;
        items[currentNumItems][ITEM_TYPE] = ITEM_HEART;
      }
    }

    currentNumItems++;
  }

  // Coffee
  randI = random(1, 4);
  if (randI == 1)
  {
    OkPosition = false;
    while (!OkPosition)
    {
      randXStart =  1;
      randXEnd   = 11;
      randYStart =  1;
      randYEnd   =  7;

      randX = random(randXStart, randXEnd);
      randY = random(randYStart, randYEnd);
        
      OkPosition = OkItemPosition(randX, randY);

      if (OkPosition)
      {
        items[currentNumItems][ITEM_X]    = randX * WALL_SIZE_X;
        items[currentNumItems][ITEM_Y]    = randY * WALL_SIZE_Y;
        items[currentNumItems][ITEM_TYPE] = ITEM_COFFEE;
      }
    }

    currentNumItems++;
  }

  // Grass
  while (currentNumItems < MAX_NUM_OF_ITEM)
  {
    OkPosition = false;
    while (!OkPosition)
    {
      randXStart =  1;
      randXEnd   = 11;
      randYStart =  1;
      randYEnd   =  7;

      randX = random(randXStart, randXEnd);
      randY = random(randYStart, randYEnd);
        
      OkPosition = OkItemPosition(randX, randY);

      if (OkPosition)
      {
        items[currentNumItems][ITEM_X]    = randX * WALL_SIZE_X;
        items[currentNumItems][ITEM_Y]    = randY * WALL_SIZE_Y;
        items[currentNumItems][ITEM_TYPE] = ITEM_GRASS;
      }
    }

    currentNumItems++;
  }
  
  // Enemies
  if (roomX == 8 && roomY == 10) // Start room, no ghosts!
    NoGhosts();
  else
  {
    randX = 0;
    randY = 0;
    byte randG = 0;

    for (int g = 0; g < currentNumGhosts; g++)
    {
      OkPosition = false;

      randXStart =  1;
      randXEnd   = 11;
      randYStart =  1;
      randYEnd   =  7;

      // Starting point of randow ghost X-pos
      if (avatarX < 10)
      {
        randXStart = 5;
        randXEnd = 11;
      } 
      else if (avatarX > 80)
      {
        randXStart = 1;
        randXEnd = 6;
      }

      // Starting point of random ghost Y-pos
      if (avatarY < 10)
      {
        randYStart = 3;
        randYEnd = 7;
      }
      else if (avatarY > 50)
      {
        randYStart = 1;
        randYEnd = 5;
      }

      while (!OkPosition)
      {
        randX = random(randXStart, randXEnd);
        randY = random(randYStart, randYEnd);
        randG = random(1, 8);

        OkPosition = OkItemPosition(randX, randY);

        if (OkPosition)
        {
          byte enemy = 0;
          
          if (randG == 1 || randG == 2)
            enemy = 1;
          else if (randG == 3 || randG == 4)
            enemy = 2;
          else if (randG == 5 || randG == 6)
            enemy = 3;
          else if (randG == 7)
            enemy = 4;
          else
            enemy = 1;
          
          ghosts[g][GHOST_X]     = randX * WALL_SIZE_X;
          ghosts[g][GHOST_Y]     = randY * WALL_SIZE_Y;
          ghosts[g][GHOST_TYPE]  = enemy;
        }
      }
    }
  }
}

boolean OkItemPosition(byte randX, byte randY)
{
  // Check wall position
  unsigned int pos = (randY * MAX_ROOM_X) + roomX + (roomY * MAX_ROOM_X * ROOM_SIZE_Y);
  unsigned int roomLine = pgm_read_word_near(mapBits + pos);
  
  if ((roomLine & bits[randX]) == bits[randX])
    return false;
  else
  {
    // Check avatar position
    if (randX == avatarX && randY == avatarY)
      return false;
    else
    {
      // Check other ghost positions
      for (int g = 0; g < currentNumGhosts; g++)
      {
        if (randX * GHOST_WIDTH == ghosts[g][GHOST_X] && randY * GHOST_HEIGHT == ghosts[g][GHOST_Y])
          return false;
        else
          return true;
      }
    }
  }
}

void CollisionAvatarAndItems()
{
  for (int i = 0; i < MAX_NUM_OF_ITEM; i++)
  {
    if (items[i][ITEM_TYPE] != ITEM_GRASS && items[i][ITEM_TYPE] != NO_ITEM)
    {
      int diffX = avatarX - items[i][ITEM_X];
      int diffY = avatarY - items[i][ITEM_Y];

      int diffXAbs = abs(diffX);
      int diffYAbs = abs(diffY);

      if (diffXAbs <= AVATAR_WIDTH && diffYAbs <= AVATAR_HEIGHT)
      {
        if (items[i][ITEM_TYPE] == ITEM_HEART)
          lives++;
        else if (items[i][ITEM_TYPE] == ITEM_APPLE)
          score += 3;
        else if (items[i][ITEM_TYPE] == ITEM_FLOWER)
          score += 5;
        else if (items[i][ITEM_TYPE] == ITEM_COFFEE)
          score += 7;
        else if (items[i][ITEM_TYPE] == ITEM_POTION)
          potionLevel = POTION_LEVEL;
          
        UnDrawItem(i);
        
        items[i][ITEM_X] = NO_ITEM;
        items[i][ITEM_Y] = NO_ITEM;
        items[i][ITEM_TYPE] = NO_ITEM;
      }
    }
  }
}

boolean CollisionAvatarAndGhosts()
{
  if (roomX == 8 && roomY == 10) // Start room, no ghosts!
    return false;

  for (int g = 0; g < currentNumGhosts; g++)
  {
    if (ghosts[g][GHOST_X] != NO_GHOST && ghosts[g][GHOST_Y] != NO_GHOST)
    {
      int diffX = avatarX - ghosts[g][GHOST_X];
      int diffY = avatarY - ghosts[g][GHOST_Y];

      int diffXAbs = abs(diffX);
      int diffYAbs = abs(diffY);

      if (diffXAbs <= AVATAR_WIDTH && diffYAbs <= AVATAR_HEIGHT)
        return true;
    }
  }

  return false;
}

byte AvatarKillingGhost()
{
  if (roomX == 8 && roomY == 10) // Start room, no ghosts!
    return NO_GHOST;

  if (fencing)
  {
    for (byte g = 0; g < currentNumGhosts; g++)
    {
      if (ghosts[g][GHOST_X] != NO_GHOST && ghosts[g][GHOST_Y] != NO_GHOST)
      {
        int diffX = avatarX - ghosts[g][GHOST_X];
        int diffY = avatarY - ghosts[g][GHOST_Y];

        int diffXAbs = abs(diffX);
        int diffYAbs = abs(diffY);

        if (ghosts[g][GHOST_TYPE] == GHOST_TYPE_SKULL)
        {
          if (potionLevel == 0)
            return NO_GHOST;
          else
            return g;
        }

        if (diffXAbs <= AVATAR_WIDTH && diffYAbs <= AVATAR_HEIGHT && //ghosts[g][GHOST_STATE] == GHOST_STATE_NORMAL &&
           ((avatarDirection == DIRECTION_RIGHT && ghosts[g][GHOST_X] > avatarX) || 
            (avatarDirection == DIRECTION_LEFT  && avatarX > ghosts[g][GHOST_X]) ||
            (avatarDirection == DIRECTION_UP    && avatarY > ghosts[g][GHOST_Y]) || 
            (avatarDirection == DIRECTION_DOWN  && ghosts[g][GHOST_Y] > avatarY)))
          return g;
      }
    }
  }

  return NO_GHOST;
}

//////////////////
// Pct handling //
//////////////////
void InitPctBits()
{
  for (byte y = 0; y < PCT_BIT_BYTES; y++)
    pctBits[y] = 0;

  pct = 0;
}

void AddPctBits(byte x, byte y)
{
  pctBits[y] = pctBits[y] | bits[x];
}

byte CalcPct()
{
  byte calcBits = 0;
  for (byte y = 0; y < PCT_BIT_BYTES; y++)
  {
    for (byte x = 0; x < PCT_BIT_BYTES; x++)
    {
      if ((pctBits[y] & bits[x]) == bits[x])
        calcBits++;
    }
  }

  return (calcBits * 100) / 256;
}

/////////////////////
// Eeprom handling //
/////////////////////
void SaveHiscore(unsigned int score, byte pctScore)
{
  EEPROM.write(0, ((score >> 8) & 0xFF));
  EEPROM.write(1, (score & 0xFF));
  EEPROM.write(2, pctScore);
}

void FetchHiscore()
{
  // Hiscore
  byte hi = EEPROM.read(0);
  byte lo = EEPROM.read(1);

  unsigned int eepromHiscore = (hi << 8) | lo;
  
  if (eepromHiscore != 65535)
    hiscore = eepromHiscore;
  else 
    hiscore = 0;

  // Pct
  byte eepromPctHiscore = (byte)EEPROM.read(2);  
  
  if (eepromPctHiscore != 255)
    pctHiscore = eepromPctHiscore;
  else
    pctHiscore = 0;
}
