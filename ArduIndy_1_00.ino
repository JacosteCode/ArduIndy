#include <Arduboy.h>
#include <EEPROM.h>

#define STATE_MENU_MAIN     1
#define STATE_MENU_PLAY     2
#define STATE_GAME_PLAYING  3
#define STATE_GAME_PAUSE    4
#define STATE_GAME_OVER     5
#define STATE_PAUSED        6
#define STATE_GAME_WON      7

#define SCREEN_WIDTH       95
#define SCREEN_HEIGHT      63
#define MAX_ROOM_X         16
#define MAX_ROOM_Y         16
#define PCT_BIT_BYTES      16
#define ROOM_SIZE_X        12
#define ROOM_SIZE_Y         8
#define WALL_SIZE_X         8
#define WALL_SIZE_Y         8

#define AVATAR_HEIGHT       8
#define AVATAR_WIDTH        8
#define AVATAR_STEP_CHANGE  2

#define GHOST_WIDTH         8
#define GHOST_HEIGHT        8
#define MAX_NUM_OF_GHOST    5
#define GHOST_DETAILS       4
#define GHOST_X             0
#define GHOST_Y             1
#define GHOST_STATE         2
#define GHOST_TYPE          3
#define GHOST_TYPE_GHOST    1
#define GHOST_TYPE_FOG      2
#define NO_GHOST          255
#define GHOST_STEP_CHANGE   1
#define GHOST_STATE_NORMAL  0
#define GHOST_STATE_HALF    1
#define GHOST_STATE_GONE    2
#define GHOST_STATE_SELF    3
#define MAX_LIVES           6

#define BITMAP_POS          2
#define BITMAPS            50
#define BITMAP_X            0
#define BITMAP_Y            1
#define BITMAP_NODATA     255

#define NO_KEYS             4
#define KEY_WIDTH           8
#define KEY_HEIGHT          8

#define EXIT_WIDTH         25
#define EXIT_HEIGHT        12

#define GHOST_SCORE        10
#define PCT_SCORE          25
#define KEY_SCORE         100

#define DIRECTION_UP        1
#define DIRECTION_DOWN      2
#define DIRECTION_LEFT      3
#define DIRECTION_RIGHT     4

Arduboy arduboy;

unsigned char gameState       = STATE_MENU_MAIN;
unsigned char avatarDirection = 0;

boolean       cheat         = false;
boolean       soundYes      = false;
boolean       facingRight   = true;
boolean       fencing       = false;
boolean       keys[NO_KEYS] = { false, false, false, false };

unsigned int  score        = 0;
unsigned int  hiscore      = 0;
unsigned int  fencingGauge = 0;
unsigned int  bits[]       = { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768 };
unsigned int  pctBits[PCT_BIT_BYTES];

int           avatarY      = 0;
int           avatarX      = 0;
int           ghosts[MAX_NUM_OF_GHOST][GHOST_DETAILS];

byte          NUM_KILLS_ADD_LIVE = 10;
byte          pct                =  0;
byte          pctHiscore         =  0;
byte          roomX              =  0;
byte          roomY              =  0;
byte          lives              =  0;
byte          ghostInitCounter   =  0;
byte          avatarFrame        =  0;
byte          numberBitMaps      =  0;
byte          currentNumGhosts   =  0;
byte          killCounter        =  0;
byte          roomBitMaps[BITMAPS][BITMAP_POS];

PROGMEM const byte outerWallImg[]            = { 0xEE, 0xEE, 0xEE, 0x00, 0xBB, 0xBB, 0xBB, 0x00 };
PROGMEM const byte innerWallImg[]            = { 0xe6, 0xc6, 0x82, 0x10, 0x30, 0x64, 0xce, 0x00 };
PROGMEM const byte exitRoomWallImg[]         = { 0x08, 0x0c, 0xfe, 0xff, 0xfe, 0x0c, 0x08, 0x00 };

PROGMEM const byte heartImgFull[]            = { 0x0e, 0x3f, 0x7f, 0xfe, 0xfe, 0x7f, 0x3f, 0x0e };
PROGMEM const byte heartImgEmpty[]           = { 0x0e, 0x11, 0x21, 0x42, 0x42, 0x21, 0x11, 0x0e };
PROGMEM const byte heartImgExtra[]           = { 0x18, 0x7e, 0x18 };

PROGMEM const byte avatarLeft1Img[]          = { 0x00, 0x00, 0x84, 0xc8, 0x3f, 0x7f, 0x44, 0xcc };
PROGMEM const byte avatarLeft2Img[]          = { 0x00, 0x00, 0x10, 0x88, 0xff, 0x7f, 0xcc, 0x00 };
PROGMEM const byte avatarLeft1fencingImg[]   = { 0x01, 0x02, 0x84, 0xc8, 0x3f, 0x7f, 0x44, 0xcc };
PROGMEM const byte avatarLeft2fencingImg[]   = { 0x40, 0x20, 0x10, 0x88, 0xff, 0x7f, 0xcc, 0x00 };
PROGMEM const byte avatarRight1Img[]         = { 0xcc, 0x44, 0x7f, 0x3f, 0xc8, 0x84, 0x00, 0x00 };
PROGMEM const byte avatarRight2Img[]         = { 0x00, 0xcc, 0x7f, 0xff, 0x88, 0x10, 0x00, 0x00 };
PROGMEM const byte avatarRight1fencingImg[]  = { 0xcc, 0x44, 0x7f, 0x3f, 0xc8, 0x84, 0x02, 0x01 };
PROGMEM const byte avatarRight2fencingImg[]  = { 0x00, 0xcc, 0x7f, 0xff, 0x88, 0x10, 0x20, 0x40 };
PROGMEM const byte avatarLeftFallImg[]       = { 0x00, 0x00, 0xc0, 0x90, 0xfc, 0xfc, 0x30, 0x00 };
PROGMEM const byte avatarRightFallImg[]      = { 0x00, 0x30, 0xfc, 0xfc, 0x90, 0xc0, 0x00, 0x00 };

PROGMEM const byte ghostFullImg[]            = { 0xfc, 0x7e, 0xfb, 0x7f, 0xfb, 0x7e, 0xfc, 0x00 };
PROGMEM const byte ghostDimmlImg[]           = { 0xa8, 0x54, 0xaa, 0x55, 0xaa, 0x54, 0xa8, 0x00 };
PROGMEM const byte ghostDimm2Img[]           = { 0x88, 0x04, 0xa8, 0x51, 0x28, 0x00, 0x28, 0x00 };

PROGMEM const byte ghost2FullImg[]           = { 0x34, 0x6e, 0xd5, 0x3d, 0xea, 0xb7, 0x6d, 0x26 };

PROGMEM const byte keyImg[]                  = { 0x00, 0x00, 0xa6, 0xa9, 0xf9, 0x06, 0x00, 0x00 };

PROGMEM const byte fenceImg[]                = { 0xfe, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xfe, 0x00 };

PROGMEM const byte gameOverImg[]             = { 0xfc, 0xfe, 0xf7, 0xc3, 0xf7, 0xfe, 0xfc, 0x00 };

PROGMEM const byte exitImg[]                 = { 0xf8, 0x0c, 0xea, 0xa9, 0xa9, 0x29, 0x09, 0x29, 0x49, 0x89, 0x49, 0x29, 0x09, 0xe9, 0x09, 0x29, 0x29, 0xe9, 0x29, 0x29, 0x09, 0xf9, 0x05, 0x03, 0xff, 0x0f, 0x08, 0x0b, 0x0a, 0x0a, 0x0a, 0x08, 0x0a, 0x09, 0x08, 0x09, 0x0a, 0x08, 0x0b, 0x08, 0x08, 0x08, 0x0b, 0x08, 0x08, 0x08, 0x0f, 0x04, 0x02, 0x01 };

PROGMEM const unsigned char imgMain[]        = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x8f, 0xe7, 0xf3, 0xfb, 0xfb, 0xfb, 0xfb, 0x7b, 0x13, 0xc7, 0xff, 0xff, 0x7f, 0x0f, 0xe7, 0xf7, 0xf3, 0x3b, 0xbb, 0xbb, 0x73, 0xf7, 0xf7, 0xe7, 0x6f, 0x0f, 0xff, 0x7f, 0x0f, 0xe7, 0xf7, 0xf7, 0x77, 0x77, 0xf7, 0xf7, 0xe7, 0xcf, 0x1f, 0xff, 0xff, 0x7f, 0x1f, 0xc7, 0xf3, 0xfb, 0x3b, 0x8b, 0xe3, 0xff, 0x1f, 0xc7, 0xf3, 0xfb, 0x7b, 0x0b, 0xe3, 0x1f, 0x47, 0x73, 0xfb, 0xfb, 0xfb, 0xfb, 0x7b, 0x7b, 0x7b, 0x3b, 0x8b, 0xe3, 0x7f, 0x0f, 0xe7, 0xf7, 0xf3, 0xfb, 0x03, 0x7f, 0x1f, 0xc3, 0xfb, 0xf3, 0x37, 0x87, 0xff, 0x1f, 0xc7, 0xf7, 0xf7, 0xf7, 0x77, 0x77, 0xf7, 0xe7, 0xef, 0xcf, 0x1f, 0xff, 0xff, 0x07, 0xf7, 0xf7, 0xf7, 0x07, 0xbf, 0x8f, 0xe7, 0xf7, 0x77, 0x37, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x8f, 0xe7, 0xf1, 0xfc, 0x7f, 0x1f, 0x07, 0xf3, 0xff, 0xff, 0xff, 0x0f, 0xe0, 0xff, 0x3f, 0x8f, 0xe3, 0xf8, 0xff, 0x7f, 0x7f, 0xfb, 0xf8, 0xdd, 0x1c, 0x4e, 0xe7, 0xf3, 0xf8, 0x7e, 0x1f, 0xc3, 0xf8, 0xff, 0xbf, 0x83, 0xd8, 0xce, 0xe7, 0x70, 0x3f, 0x9f, 0xc7, 0xf0, 0x1f, 0xc3, 0xf8, 0xff, 0xff, 0x87, 0xb0, 0x9e, 0xcf, 0xe3, 0x78, 0x3e, 0x9f, 0xc7, 0xf1, 0xfc, 0x7f, 0x1f, 0xc3, 0xf8, 0xff, 0xff, 0x7f, 0x1f, 0xc7, 0xf0, 0xff, 0xff, 0x3f, 0x8f, 0xe3, 0xf8, 0x7f, 0x1f, 0x3f, 0xff, 0xff, 0xff, 0xfc, 0xff, 0x1f, 0xc3, 0xf8, 0x3e, 0x87, 0xf1, 0xfc, 0xff, 0x9f, 0xc3, 0xd8, 0xce, 0x63, 0x38, 0x9f, 0xcf, 0xe3, 0xf8, 0x7f, 0x0f, 0xe0, 0xff, 0xff, 0x3f, 0x8f, 0xe7, 0xf3, 0xf9, 0xfc, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x1f, 0x47, 0x71, 0x7c, 0x7f, 0x3f, 0x8f, 0xe7, 0xf7, 0x17, 0x47, 0x7f, 0x3f, 0xbf, 0xbf, 0x81, 0xfc, 0xf3, 0xf0, 0xf6, 0xf7, 0xf7, 0xf1, 0xfc, 0xff, 0xf0, 0xf7, 0xf3, 0xfb, 0xfb, 0xf8, 0xff, 0xff, 0xf1, 0xf4, 0xf7, 0xf7, 0xf3, 0xfb, 0xfb, 0xf9, 0xfd, 0xfc, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfc, 0xf9, 0xfb, 0xfb, 0xfb, 0xfb, 0xf9, 0xfd, 0xfc, 0xfe, 0xff, 0x0f, 0x63, 0x7b, 0x39, 0xbc, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0x9c, 0xc5, 0xf1, 0xff, 0xf7, 0xf0, 0xf6, 0xf7, 0xf3, 0xf3, 0xf8, 0xff, 0xfe, 0xf8, 0xfb, 0xfb, 0xfb, 0xf8, 0xfe, 0xff, 0xf0, 0xf6, 0xf7, 0xf3, 0xfb, 0xfb, 0xfb, 0xf9, 0xfd, 0xfc, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xf1, 0xf4, 0xf7, 0xf7, 0xf7, 0xf0, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x83, 0x6f, 0x6f, 0x6f, 0x9f, 0xff, 0x8f, 0x7f, 0x7f, 0x7f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0x7f, 0x7b, 0x7b, 0x83, 0xff, 0x07, 0xdb, 0xdb, 0xdb, 0x07, 0xff, 0x87, 0x7b, 0x7b, 0x7b, 0xb7, 0xff, 0x87, 0x7b, 0x7b, 0x7b, 0x87, 0xff, 0xb7, 0x6b, 0x6b, 0x6b, 0x9b, 0xff, 0xfb, 0xfb, 0x03, 0xfb, 0xfb, 0xff, 0x03, 0x6b, 0x6b, 0x7b, 0x7b, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0d, 0x0b, 0x0b, 0x0b, 0x0c, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f };

PROGMEM const unsigned int mapBits[]         = { 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x800, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x800, 0xFF1, 0xFFF, 0xFFF, 0xFFF, 0x801, 0xFFF, 0xFFF, 0x801, 0xFFF, 0xFFF, 0xE07, 0xFFF, 0xFFF, 0xFFF, 0x803, 0x801, 0x1, 0x0, 0x0, 0x100, 0x801, 0x0, 0x0, 0x801, 0x1, 0x200, 0x4, 0x0, 0x200, 0x0, 0x802, 0x801, 0x1, 0x0, 0x0, 0x100, 0x801, 0x0, 0x0, 0x801, 0x1, 0x200, 0x4, 0x0, 0x200, 0x0, 0x802, 0x801, 0x1, 0x0, 0x0, 0x100, 0x801, 0x0, 0x0, 0x801, 0x1, 0x200, 0x4, 0x0, 0x200, 0x0, 0x802, 0x801, 0xFFF, 0xFFF, 0xFFF, 0xF1F, 0xFC3, 0xFFF, 0xFFF, 0xF8F, 0xFFF, 0xF87, 0xFFF, 0xFFF, 0xF8F, 0xFFF, 0xF0F, 0xF87, 0xFFF, 0xFFF, 0xFFF, 0xF1F, 0xFC3, 0xFFF, 0xFFF, 0xF8F, 0xFFF, 0xF87, 0xFFF, 0xFFF, 0xF8F, 0xFFF, 0xF0F, 0xF87, 0x1, 0x200, 0x2, 0x100, 0x2, 0x800, 0x1, 0x400, 0x2, 0x80, 0x1, 0x200, 0x4, 0x0, 0x0, 0x804, 0x1, 0x200, 0x2, 0x100, 0x2, 0x800, 0x1, 0x400, 0x2, 0x80, 0x1, 0x200, 0x4, 0x0, 0x0, 0x804, 0xFF1, 0xE3F, 0xC0F, 0xF07, 0xFFF, 0x8C7, 0xE31, 0xFFF, 0xE1F, 0xFFF, 0xFFF, 0xE0F, 0xFFF, 0xFFF, 0xC03, 0x87F, 0x1, 0x200, 0x2, 0x100, 0x2, 0x800, 0x1, 0x400, 0x2, 0x80, 0x1, 0x200, 0x4, 0x0, 0x0, 0x800, 0x1, 0x200, 0x2, 0x100, 0x2, 0x800, 0x1, 0x400, 0x2, 0x80, 0x1, 0x200, 0x4, 0x0, 0x0, 0x800, 0x1, 0x200, 0x2, 0x100, 0x2, 0x800, 0x1, 0x400, 0x2, 0x80, 0x1, 0x200, 0x4, 0x0, 0x0, 0x800, 0xFF1, 0xE3F, 0xF1F, 0xFFF, 0xF0F, 0xFFF, 0xFFF, 0xF8F, 0xE3F, 0xF8F, 0xF8F, 0xFC7, 0xFC7, 0xFFF, 0xF0F, 0xFFF, 0xFF1, 0xE3F, 0xF1F, 0xFFF, 0xF0F, 0xFFF, 0xFFF, 0xF8F, 0xE3F, 0xF8F, 0xF8F, 0xFC7, 0xFC7, 0xFFF, 0xF0F, 0xFFF, 0x11, 0x201, 0x101, 0x1, 0x0, 0x800, 0x801, 0x888, 0x201, 0x4, 0x200, 0x44, 0x42, 0xC03, 0x4, 0x800, 0x11, 0x201, 0x101, 0x1, 0x0, 0x800, 0x801, 0x988, 0x201, 0x4, 0x200, 0xC4, 0xC2, 0xC03, 0x4, 0x800, 0xFF1, 0xFF1, 0xFF1, 0xC71, 0xC03, 0x8E3, 0xC03, 0x90F, 0xFF1, 0xFFF, 0xFFF, 0x87, 0x82, 0x801, 0xFFF, 0x87F, 0x11, 0x101, 0x101, 0x1, 0x0, 0x800, 0x801, 0xB08, 0x201, 0x4, 0x200, 0x184, 0x182, 0x801, 0x4, 0x800, 0x11, 0x101, 0x101, 0x1, 0x0, 0x800, 0x801, 0xA08, 0x201, 0x4, 0x200, 0x104, 0x102, 0xC03, 0x4, 0x800, 0x11, 0x101, 0x101, 0x1, 0x0, 0x800, 0x801, 0xA08, 0x201, 0x4, 0x200, 0x104, 0x102, 0xC03, 0x4, 0x800, 0xFF1, 0xF1F, 0xF1F, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF8F, 0xE3F, 0xF8F, 0xF8F, 0xFC7, 0xF8F, 0xF1F, 0xFC7, 0xC7F, 0xFF1, 0xF1F, 0xF1F, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF8F, 0xE3F, 0xF8F, 0xF8F, 0xFC7, 0xF8F, 0xF1F, 0xFC7, 0xC7F, 0x211, 0x910, 0x10, 0x800, 0x801, 0x801, 0x101, 0x2, 0x200, 0x801, 0x1, 0x0, 0x0, 0x800, 0x1, 0x808, 0x211, 0xA10, 0x10, 0x800, 0x801, 0x801, 0x101, 0x2, 0x200, 0x801, 0x1, 0x0, 0x0, 0x800, 0x1, 0x808, 0xE11, 0xC1F, 0xFFF, 0x8E7, 0x801, 0x801, 0xFE1, 0xF83, 0x23F, 0x801, 0xF0F, 0xF0F, 0xF81, 0x80F, 0xFFF, 0x87F, 0x211, 0x810, 0x10, 0x800, 0x801, 0x801, 0x101, 0x2, 0x200, 0x801, 0x1, 0x108, 0x80, 0x808, 0x1, 0x800, 0x211, 0xF10, 0x10, 0x800, 0x801, 0x801, 0x101, 0x2, 0x200, 0x801, 0x1, 0x108, 0x80, 0x808, 0x1, 0x800, 0x211, 0x910, 0x10, 0x800, 0x801, 0x801, 0x101, 0x2, 0x200, 0x801, 0x1, 0x108, 0x80, 0x808, 0x1, 0x800, 0xFF1, 0xF1F, 0xF1F, 0xFFF, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xFFF, 0xFFF, 0xF1F, 0xF0F, 0xF8F, 0xF8F, 0xFC3, 0xFFF, 0xFF1, 0xF1F, 0xF1F, 0xFFF, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xFFF, 0xFFF, 0xF1F, 0xF0F, 0xF8F, 0xF8F, 0xFC3, 0xFFF, 0x1, 0x200, 0x101, 0x801, 0x801, 0x308, 0x801, 0x1, 0x0, 0x0, 0x200, 0xB04, 0x801, 0x801, 0x1, 0x800, 0x1, 0x200, 0x101, 0x801, 0x801, 0xE08, 0x801, 0x1, 0x0, 0x0, 0x200, 0xE04, 0x801, 0x801, 0x1, 0x800, 0xFE1, 0xE3F, 0xFE1, 0x801, 0x801, 0xC0F, 0xFE1, 0x8F1, 0xFFF, 0xFFF, 0xE1F, 0xC07, 0xFE1, 0x801, 0xF81, 0x83F, 0x1, 0x200, 0x101, 0x801, 0x801, 0x808, 0x801, 0x1, 0x0, 0x0, 0x200, 0x804, 0x801, 0x801, 0x1, 0x800, 0x1, 0x200, 0x101, 0x801, 0x801, 0x808, 0x801, 0x1, 0x0, 0x0, 0x200, 0x804, 0x801, 0x801, 0x1, 0x800, 0x1, 0x200, 0x101, 0x801, 0x801, 0x808, 0x801, 0x1, 0x0, 0x0, 0x200, 0x804, 0x801, 0x801, 0x1, 0x800, 0xFF1, 0xFFF, 0xF1F, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xF0F, 0xF8F, 0xFFF, 0xFC3, 0xC7F, 0xFF1, 0xFFF, 0xF1F, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xF0F, 0xF8F, 0xFFF, 0xFC3, 0xC7F, 0x1, 0x200, 0x801, 0x1, 0x0, 0x200, 0x4, 0x800, 0x801, 0x801, 0x1, 0x400, 0xB02, 0x1, 0x0, 0x808, 0x1, 0x200, 0x801, 0x1, 0x0, 0x200, 0x4, 0x800, 0x801, 0x801, 0x1, 0x400, 0xE02, 0x1, 0x0, 0x808, 0xFE1, 0xE3F, 0x801, 0xFF1, 0xFFF, 0xE1F, 0xFFF, 0x8F1, 0x801, 0x801, 0x8F1, 0xFFF, 0x80F, 0x8F1, 0x801, 0x8FF, 0x1, 0x200, 0x801, 0x1, 0x0, 0x200, 0x4, 0x800, 0x801, 0x801, 0x1, 0x400, 0x802, 0x1, 0x0, 0x800, 0x1, 0x200, 0x801, 0x1, 0x0, 0x200, 0x4, 0x800, 0x801, 0x801, 0x1, 0x400, 0x802, 0x1, 0x0, 0x800, 0x1, 0x200, 0x801, 0x1, 0x0, 0x200, 0x4, 0x800, 0x801, 0x801, 0x1, 0x400, 0x802, 0x1, 0x0, 0x800, 0xFF1, 0xF1F, 0xF1F, 0xFC3, 0xFFF, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xF87, 0xFFF, 0xFC3, 0xFFF, 0xFF1, 0xF1F, 0xF1F, 0xFC3, 0xFFF, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xF87, 0xFFF, 0xFC3, 0xFFF, 0x1, 0x200, 0x4, 0x0, 0x0, 0x800, 0x1, 0x0, 0x0, 0x8, 0x800, 0x401, 0x2, 0x0, 0x100, 0x800, 0x1, 0x200, 0x4, 0x0, 0x0, 0x800, 0x1, 0x0, 0x0, 0x8, 0x800, 0x401, 0x2, 0x0, 0x100, 0x800, 0xFE1, 0xFFF, 0xFFF, 0x801, 0xFFF, 0x871, 0xFFF, 0xFFF, 0x801, 0xFFF, 0x8F1, 0xFF1, 0xFFF, 0xFFF, 0xFFF, 0x83F, 0x1, 0x200, 0x4, 0x0, 0x0, 0x800, 0x1, 0x0, 0x0, 0x8, 0x800, 0x401, 0x2, 0x0, 0x100, 0x800, 0x1, 0x200, 0x4, 0x0, 0x0, 0x800, 0x1, 0x0, 0x0, 0x8, 0x800, 0x401, 0x2, 0x0, 0x100, 0x800, 0x1, 0x200, 0x4, 0x0, 0x0, 0x800, 0x1, 0x0, 0x0, 0x8, 0x800, 0x401, 0x2, 0x0, 0x100, 0x800, 0xFF1, 0xF1F, 0xF1F, 0xF0F, 0xFFF, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xF8F, 0xFFF, 0xF8F, 0xE3F, 0xFF1, 0xF1F, 0xF1F, 0xF0F, 0xFFF, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xF8F, 0xFFF, 0xF8F, 0xE3F, 0x111, 0x8, 0x200, 0x801, 0x801, 0x1, 0x0, 0x108, 0x0, 0x108, 0x800, 0x1, 0x200, 0x1, 0x100, 0x800, 0x111, 0x8, 0x200, 0x801, 0x801, 0x1, 0x0, 0x108, 0x0, 0x108, 0x800, 0x1, 0x200, 0x1, 0x100, 0x800, 0xF11, 0xFFF, 0xFFF, 0x801, 0x801, 0x8F1, 0x801, 0xF0F, 0xFE1, 0xF0F, 0x8F1, 0xFFF, 0xFFF, 0x8F1, 0xFFF, 0x83F, 0x111, 0x8, 0x200, 0x801, 0x801, 0x1, 0x0, 0x0, 0x0, 0x0, 0x800, 0x1, 0x200, 0x1, 0x100, 0x800, 0x111, 0x8, 0x200, 0x801, 0x801, 0x1, 0x0, 0x0, 0x0, 0x0, 0x800, 0x1, 0x200, 0x1, 0x100, 0x800, 0x111, 0x8, 0x200, 0x801, 0x801, 0x1, 0x0, 0x0, 0x0, 0x0, 0x800, 0x1, 0x200, 0x1, 0x100, 0x800, 0xFF1, 0xF1F, 0xF1F, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF8F, 0xFFF, 0xF8F, 0xF87, 0xFF1, 0xF1F, 0xF1F, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF8F, 0xFFF, 0xF8F, 0xF87, 0x1, 0x0, 0x0, 0x0, 0x800, 0x801, 0x201, 0x801, 0x801, 0x801, 0x801, 0x201, 0x4, 0x0, 0x100, 0x808, 0x1, 0x0, 0x0, 0x0, 0x800, 0x801, 0x201, 0x801, 0x801, 0x801, 0x801, 0x201, 0x4, 0x0, 0x100, 0x808, 0xFFF, 0x801, 0x801, 0xFFF, 0x801, 0x801, 0x3F1, 0x801, 0x801, 0x801, 0x801, 0xFF1, 0xFC7, 0xFFF, 0xF1F, 0x8FF, 0x101, 0x0, 0x0, 0x0, 0x800, 0x801, 0x201, 0x801, 0x801, 0x801, 0x801, 0x201, 0x4, 0x0, 0x100, 0x808, 0x101, 0x0, 0x0, 0x0, 0x800, 0x801, 0x201, 0x801, 0x801, 0x801, 0x801, 0x201, 0x4, 0x0, 0x100, 0x808, 0x101, 0x0, 0x0, 0x0, 0x800, 0x801, 0x201, 0x801, 0x801, 0x801, 0x801, 0x201, 0x4, 0x0, 0x100, 0x808, 0xFF1, 0xF1F, 0xF1F, 0xFFF, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xFFF, 0xFC3, 0xE1F, 0xFFF, 0xFFF, 0xFFF, 0xE3F, 0xFF1, 0xF1F, 0xF1F, 0xFFF, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xFFF, 0xFC3, 0xE1F, 0xFFF, 0xFFF, 0xFFF, 0xE3F, 0x111, 0x801, 0xB01, 0x24, 0x0, 0x400, 0x2, 0x0, 0x0, 0x0, 0x800, 0x1, 0x800, 0x801, 0x24, 0x820, 0x111, 0x801, 0xE01, 0x24, 0x0, 0x400, 0x2, 0x0, 0x0, 0x0, 0x800, 0x1, 0x800, 0x801, 0x24, 0x820, 0xF11, 0x801, 0xC01, 0xC3F, 0xC03, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0x801, 0xFFF, 0x8F1, 0x801, 0x87F, 0x83F, 0x111, 0x801, 0x801, 0x4, 0x0, 0x400, 0x2, 0x0, 0x0, 0x0, 0x800, 0x1, 0x800, 0x801, 0x4, 0x800, 0x111, 0x801, 0x801, 0x4, 0x0, 0x400, 0x2, 0x0, 0x0, 0x0, 0x800, 0x1, 0x800, 0x801, 0x4, 0x800, 0x111, 0x801, 0x801, 0x4, 0x0, 0x400, 0x2, 0x0, 0x0, 0x0, 0x800, 0x1, 0x800, 0x801, 0x4, 0x800, 0xFF1, 0xF1F, 0xF1F, 0xFC7, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xF1F, 0xE1F, 0xFFF, 0xFF1, 0xF1F, 0xF1F, 0xFC7, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xF1F, 0xE1F, 0xFFF, 0x211, 0x4, 0x200, 0x801, 0x201, 0xE04, 0x401, 0x801, 0x801, 0x801, 0x4, 0x200, 0x801, 0x401, 0x2, 0x800, 0x211, 0x4, 0x200, 0x801, 0x201, 0xC04, 0x401, 0x801, 0x801, 0x801, 0x4, 0x200, 0x801, 0x401, 0x2, 0x800, 0xE11, 0xF07, 0xE3F, 0x801, 0xFF1, 0x807, 0xFF1, 0x801, 0x801, 0x801, 0xFFF, 0xFFF, 0x801, 0xFE1, 0xFC3, 0x81F, 0x211, 0x4, 0x200, 0x801, 0x201, 0x804, 0x401, 0x801, 0x801, 0x801, 0x4, 0x200, 0x801, 0x401, 0x2, 0x800, 0x211, 0x4, 0x200, 0x801, 0x201, 0x804, 0x401, 0x801, 0x801, 0x801, 0x4, 0x200, 0x801, 0x401, 0x2, 0x800, 0x211, 0x4, 0x200, 0x801, 0x201, 0x804, 0x401, 0x801, 0x801, 0x801, 0x4, 0x200, 0x801, 0x401, 0x2, 0x800, 0xFF1, 0xFFF, 0xFFF, 0xFFF, 0xF0F, 0xE1F, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xF0F, 0xF0F, 0xF1F, 0xFFF, 0xC3F, 0xFF1, 0xFFF, 0xFFF, 0xFFF, 0xF0F, 0xE1F, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xF0F, 0xF0F, 0xF1F, 0xFFF, 0xC3F, 0x1, 0x400, 0x2, 0x0, 0x800, 0x801, 0x1, 0x400, 0x2, 0x200, 0x101, 0x0, 0x100, 0x0, 0x0, 0x800, 0x1, 0x400, 0x2, 0x0, 0x800, 0x801, 0x1, 0x400, 0x2, 0x200, 0x101, 0x0, 0x100, 0x0, 0x0, 0x800, 0xFFF, 0xC3F, 0x8E3, 0xFFF, 0x87F, 0x801, 0xFE1, 0xFFF, 0xFC3, 0xE1F, 0xFF1, 0x801, 0xFFF, 0x801, 0xFFF, 0x87F, 0x41, 0x400, 0x2, 0x0, 0x800, 0x801, 0x1, 0x400, 0x2, 0x200, 0x101, 0x0, 0x100, 0x0, 0x0, 0x800, 0x41, 0x400, 0x2, 0x0, 0x800, 0x801, 0x1, 0x400, 0x2, 0x200, 0x101, 0x0, 0x100, 0x0, 0x0, 0x800, 0x41, 0x400, 0x2, 0x0, 0x800, 0x801, 0x1, 0x400, 0x2, 0x200, 0x101, 0x0, 0x100, 0x0, 0x0, 0x800, 0xFF1, 0xF0F, 0xF0F, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xF0F, 0xF1F, 0xFFF, 0xF0F, 0xF0F, 0xF0F, 0xF1F, 0xFFF, 0xC3F, 0xFF1, 0xF0F, 0xF0F, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xF0F, 0xF1F, 0xFFF, 0xF0F, 0xF0F, 0xF0F, 0xF1F, 0xFFF, 0xC3F, 0x1, 0x0, 0x800, 0x801, 0x4, 0x0, 0x200, 0x4, 0x200, 0x1, 0x200, 0x801, 0xE04, 0xE04, 0x4, 0x800, 0x1, 0x0, 0x800, 0x801, 0x4, 0x0, 0x200, 0x4, 0x200, 0x1, 0x200, 0x801, 0xC04, 0xC04, 0x4, 0x800, 0xFE1, 0x801, 0x801, 0x801, 0x8FF, 0xFFF, 0xE3F, 0xFFF, 0xE3F, 0x8F1, 0xFFF, 0x801, 0x807, 0x807, 0x8FF, 0x83F, 0x1, 0x0, 0x800, 0x801, 0x4, 0x0, 0x200, 0x4, 0x200, 0x1, 0x200, 0x801, 0x804, 0x804, 0x4, 0x800, 0x1, 0x0, 0x800, 0x801, 0x4, 0x0, 0x200, 0x4, 0x200, 0x1, 0x200, 0x801, 0x804, 0x804, 0x4, 0x800, 0x1, 0x0, 0x800, 0x801, 0x4, 0x0, 0x200, 0x4, 0x200, 0x1, 0x200, 0x801, 0x804, 0xE04, 0x4, 0x800, 0xFF1, 0xF0F, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF1F, 0xF0F, 0xC3F, 0xFF1, 0xF0F, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xF0F, 0xFFF, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xF1F, 0xF0F, 0xC3F, 0x211, 0xE04, 0x801, 0x801, 0x4, 0x400, 0x2, 0x0, 0x0, 0x800, 0x4, 0x0, 0x400, 0x401, 0xE02, 0x802, 0x211, 0xC04, 0x801, 0x801, 0x4, 0x400, 0x2, 0x0, 0x0, 0x800, 0x4, 0x0, 0x400, 0x401, 0xC02, 0x802, 0xE11, 0x807, 0x801, 0x801, 0xFC7, 0xC7F, 0xFE3, 0x807, 0xFFF, 0x8F1, 0xFFF, 0xFFF, 0xC7F, 0xFF1, 0x803, 0x83F, 0x211, 0x804, 0x801, 0x801, 0x4, 0x400, 0x2, 0x4, 0x0, 0x800, 0x4, 0x0, 0x400, 0x401, 0x802, 0x802, 0x211, 0xC04, 0x801, 0x801, 0x4, 0x400, 0x2, 0x4, 0x0, 0x800, 0x4, 0x0, 0x400, 0x401, 0x802, 0x802, 0x211, 0xE04, 0x801, 0x801, 0x4, 0x400, 0x2, 0x4, 0x0, 0x800, 0x4, 0x0, 0x400, 0x401, 0x802, 0x803, 0xFF1, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xFFF, 0xFFF, 0xF0F, 0xFFF, 0xFFF, 0xF1F, 0xF0F, 0xC3F, 0xFF1, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xF0F, 0xFFF, 0xF0F, 0xFFF, 0xFFF, 0xF0F, 0xFFF, 0xFFF, 0xF1F, 0xF0F, 0xC3F, 0x811, 0x801, 0x801, 0x201, 0x801, 0x2, 0x400, 0x801, 0x2, 0x400, 0x401, 0x2, 0x0, 0x400, 0x201, 0x804, 0x811, 0x801, 0x801, 0x201, 0x801, 0x2, 0x400, 0x801, 0x2, 0x400, 0x401, 0x2, 0x0, 0x400, 0x201, 0x804, 0x811, 0x801, 0x801, 0xFF1, 0x801, 0xFE3, 0xC7F, 0x801, 0x8E3, 0xC3F, 0xFF1, 0xFFF, 0xFFF, 0xC7F, 0xFF1, 0x8FF, 0xFF1, 0x801, 0x801, 0x201, 0x801, 0x2, 0x400, 0x801, 0x2, 0x400, 0x401, 0x2, 0x0, 0x400, 0x201, 0x804, 0x801, 0x801, 0x801, 0x201, 0x801, 0x2, 0x400, 0x801, 0x2, 0x400, 0x401, 0x2, 0x0, 0x400, 0x201, 0x804, 0x801, 0x801, 0x801, 0x201, 0x801, 0x2, 0x400, 0x801, 0x2, 0x400, 0x401, 0x2, 0x0, 0x400, 0x201, 0x804, 0xF0F, 0xFFF, 0xFFF, 0xF0F, 0xFC3, 0xFFF, 0xF0F, 0xFFF, 0xE1F, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xFFF, 0xF0F, 0xE1F, 0xF0F, 0xFFF, 0xFFF, 0xF0F, 0xFC3, 0xFFF, 0xF0F, 0xFFF, 0xE1F, 0xF0F, 0xF0F, 0xF0F, 0xFFF, 0xFFF, 0xF0F, 0xE1F, 0x1, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x808, 0x1, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x808, 0xFE1, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0x87F, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x800, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x800, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x800, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF };

/////////////////////////
// Setup and Main loop //
/////////////////////////
void setup()
{
  arduboy.begin();
  arduboy.setFrameRate(30);
  arduboy.initRandomSeed();

  // Initialize scores in EEPROM
  //SaveHiscore(0, 0);

  FetchHiscore();
}

void loop()
{
  if (!(arduboy.nextFrame()))
    return;

  switch (gameState)
  {
    case STATE_MENU_MAIN:
      DisplayMainMenu();
      break;

    case STATE_MENU_PLAY:
      GamePlayInit();
      break;

    case STATE_GAME_PLAYING:
      GamePlaying();
      break;

    case STATE_GAME_OVER:
      DisplayGameOver();
      break;

    case STATE_GAME_WON:
      DisplayGameWon();
      break;

    case STATE_PAUSED:
      DisplayPausedGame();
      break;
  }

  arduboy.display();
}

void DisplayMainMenu()
{
  arduboy.clearDisplay();

  arduboy.drawBitmap(0, 0, imgMain, 128, 36, 1);

  arduboy.setCursor(31, 26);
  arduboy.print("v1.00");
  
  arduboy.setCursor(12, 39);
  arduboy.print("Hiscore");

  arduboy.setCursor(5, 51);
  PrintScore(hiscore);

  DrawPct(pctHiscore, 36, 51);

  arduboy.setCursor(70, 45);
  arduboy.print("'B' Play");

  arduboy.drawLine(0, 36, 0, 63, 1);
  arduboy.drawLine(1, 36, 1, 63, 1);

  arduboy.drawLine(62, 36, 62, 63, 1);
  arduboy.drawLine(63, 36, 63, 63, 1);

  arduboy.drawLine(126, 36, 126, 63, 1);
  arduboy.drawLine(127, 36, 127, 63, 1);

  arduboy.drawLine(0, 62, 127, 62, 1);
  arduboy.drawLine(0, 63, 127, 63, 1);

  if (arduboy.pressed(UP_BUTTON) && arduboy.pressed(DOWN_BUTTON))
    cheat = true;
  else if (arduboy.pressed(B_BUTTON))
    gameState = STATE_MENU_PLAY;
}

void DisplayGameOver()
{
  arduboy.clearDisplay();

  arduboy.setTextSize(2);
  arduboy.setCursor(12, 2);
  arduboy.print("GAME OVER");

  arduboy.setTextSize(1);
  arduboy.setCursor(32, 27);
  arduboy.print("SCORE");
  arduboy.setCursor(70, 27);
  PrintScore(CalcScore(score));

  arduboy.setCursor(14, 40);
  arduboy.print("PROGRESS");
  DrawPct(pct, 76, 40);
  
  arduboy.setCursor(0, 54);
  arduboy.print("Press 'LEFT' for menu");

  if (arduboy.pressed(LEFT_BUTTON) || arduboy.pressed(RIGHT_BUTTON) || arduboy.pressed(UP_BUTTON) || arduboy.pressed(DOWN_BUTTON))
    gameState = STATE_MENU_MAIN;
}

void DisplayGameWon()
{
  arduboy.clearDisplay();

  arduboy.setTextSize(2);
  arduboy.setCursor(12, 2);
  arduboy.print("YOU WON!");

  arduboy.setTextSize(1);
  arduboy.setCursor(32, 27);
  arduboy.print("Score");
  arduboy.setCursor(70, 27);
  PrintScore(CalcScore(score));

  arduboy.setCursor(14, 40);
  arduboy.print("Progress");
  DrawPct(pct, 76, 40);
  
  arduboy.setCursor(10, 54);
  arduboy.print("Press 'A' for menu");

  if (arduboy.pressed(A_BUTTON))
    gameState = STATE_MENU_MAIN;
}

void DisplayPausedGame()
{
  arduboy.clearDisplay();

  arduboy.setTextSize(2);
  arduboy.setCursor(4, 2);
  arduboy.print("GAME PAUSE");

  arduboy.setTextSize(1);
  arduboy.setCursor(32, 27);
  arduboy.print("Score");
  arduboy.setCursor(70, 27);
  PrintScore(CalcScore(score));

  arduboy.setCursor(14, 40);
  arduboy.print("Progress");
  DrawPct(pct, 76, 40);

  arduboy.setCursor(10, 54);
  arduboy.print("Press 'B' for game");

  if (arduboy.pressed(B_BUTTON))
  {
    gameState = STATE_GAME_PLAYING;
    RoomChange();
  }
}

void GamePlayInit()
{
  roomX            = 8;
  roomY            = 10; 
  score            = 0;
  avatarY          = 28;
  avatarX          = 44;
  lives            = MAX_LIVES;
  currentNumGhosts = 0;
  killCounter      = 0;
  fencingGauge     = 0;

  arduboy.clearDisplay();

  InitKeys();
  SetNumberOfGhosts();
  RoomChange();
  InitPctBits();

  if (soundYes == true)
    arduboy.audio.on();
  else
    arduboy.audio.off();

  gameState = STATE_GAME_PLAYING;
}

void GamePlaying()
{
  UnDrawGhosts();
  GhostsMovement();
      
  CheckFindKeys();

  UnDrawAvatar();
      
  if (arduboy.pressed(LEFT_BUTTON))
  {
    facingRight = false;

    if (avatarX <= 0)
    {
      roomX--;
      avatarX = SCREEN_WIDTH - AVATAR_WIDTH;
      RoomChange();
    }

    if (!WallCollision(avatarX - AVATAR_STEP_CHANGE, avatarY, "L"))
      avatarX -= AVATAR_STEP_CHANGE;

    avatarDirection = DIRECTION_LEFT;
  }
  else if (arduboy.pressed(RIGHT_BUTTON))
  {
    facingRight = true;

    if (avatarX >= SCREEN_WIDTH - AVATAR_WIDTH)
    {
      roomX++;
      avatarX = 0;
      RoomChange();
    }

    if (!WallCollision(avatarX + AVATAR_STEP_CHANGE, avatarY, "R"))
      avatarX += AVATAR_STEP_CHANGE;

    avatarDirection = DIRECTION_RIGHT;
  }
  else if (arduboy.pressed(DOWN_BUTTON))
  {
    if (avatarY >= SCREEN_HEIGHT - AVATAR_HEIGHT)
    {
      roomY++;
      avatarY = 0;
      RoomChange();
    }

    if (!WallCollision(avatarX, avatarY + AVATAR_STEP_CHANGE, "D"))
      avatarY += AVATAR_STEP_CHANGE;

    avatarDirection = DIRECTION_DOWN;
  }
  else if (arduboy.pressed(UP_BUTTON))
  {
    if (avatarY <= 0)
    {
      roomY--;
      avatarY = SCREEN_HEIGHT - AVATAR_HEIGHT;
      RoomChange();
    }

    if (!WallCollision(avatarX, avatarY - AVATAR_STEP_CHANGE, "U"))
      avatarY -= AVATAR_STEP_CHANGE;

    avatarDirection = DIRECTION_UP;
  }

  if (arduboy.pressed(A_BUTTON + B_BUTTON)) // Main menu
    gameState = STATE_MENU_MAIN;

  if (arduboy.pressed(A_BUTTON)) // Paused game
    gameState = STATE_PAUSED;

  if (arduboy.pressed(B_BUTTON)) // fencing
  {
    if (fencingGauge < 300)
    {
      fencingGauge++;

      if (fencingGauge < 255)
        fencing = true;
      else
        fencing = false;
    }
    else
      fencing = false;
  }
  else
    fencing = false;
  
  if (!fencing && fencingGauge > 0)
    fencingGauge--;

  if (CollisionAvatarAndGhosts())
  {
    byte ghostNo = AvatarKillingGhost();
    
    if (ghostNo != NO_GHOST)
      GhostHit(ghostNo);
    else
      AvatarHit();
  }

  SetNumberOfGhosts();
    
  BuildScreen();

  if (ExitFound())
    gameState = STATE_GAME_WON;
  else if (GameOver())
  {
    DrawGameOverScreen();
    gameState = STATE_GAME_OVER;
  }
}

void SetNumberOfGhosts()
{
  byte tempCurrNumGhosts = currentNumGhosts;
  
  if (pct < 10)
    currentNumGhosts = 1;
  else if (pct >= 10 && pct < 40)
    currentNumGhosts = 2;
  else if (pct >= 40 && pct < 60)
    currentNumGhosts = 3;
  else if (pct >= 60 && pct < 80)
    currentNumGhosts = 4;
  else if (pct >= 80)
    currentNumGhosts = 5;

  if (currentNumGhosts != tempCurrNumGhosts)
    RoomChange();
}

void GhostHit(byte killedGhostNo)
{
  score += GHOST_SCORE;
  DrawScores();
  
  DrawAvatar(false);
  
  ghosts[killedGhostNo][GHOST_STATE] = GHOST_STATE_HALF;
  DrawGhosts(GHOST_STATE_SELF);
  arduboy.display();
  
  delay(50);
  ghosts[killedGhostNo][GHOST_STATE] = GHOST_STATE_GONE;
  DrawGhosts(GHOST_STATE_SELF);
  arduboy.display();
  
  delay(50);
  UnDrawGhost(killedGhostNo);

  ghosts[killedGhostNo][GHOST_X]     = NO_GHOST;
  ghosts[killedGhostNo][GHOST_Y]     = NO_GHOST;
  ghosts[killedGhostNo][GHOST_STATE] = NO_GHOST;
  ghosts[killedGhostNo][GHOST_TYPE]  = NO_GHOST;

  killCounter++;
  if (killCounter == NUM_KILLS_ADD_LIVE)
  {
    killCounter = 0;
    lives++;
  }
}

void AvatarHit()
{
  lives--;
  
  DrawLives();
  DrawAvatar(true);
  DrawGhosts(GHOST_STATE_HALF);
  arduboy.display();
  delay(1000);
  
  UnDrawGhosts();
  DrawGhosts(GHOST_STATE_GONE);
  arduboy.display();
  delay(1000);
  
  UnDrawGhosts();
  NoGhosts(); // remove ghosts, to avoid quickly death!
  DrawAvatar(false);
}

//////////////////
// Misc methods //
//////////////////
boolean GameOver()
{
  if (lives == 0)
  {
    unsigned int fullScore = CalcScore(score);
    if (fullScore > hiscore)
    {
      hiscore    = fullScore;
      pctHiscore = pct;
      SaveHiscore(hiscore, pctHiscore);
    }
     
    return true;
  }
  else
    return false;
}

boolean ExitFound()
{
  if (roomX == 8 && roomY == 8 && avatarX > 32 && avatarX < 57 && avatarY > 20 && avatarY < 32)
    return true;
  else
    return false;
}

/////////////////////
// Screen handling //
/////////////////////
void BuildScreen()
{
  DrawScores();
  DrawAvatar(false);
  DrawGhosts(GHOST_STATE_SELF);
  DrawKey();
  DrawExit();
}

void DrawWalls()
{
  for (byte b = 0; b < numberBitMaps; b++)
  {
    if (roomBitMaps[b][BITMAP_X] != BITMAP_NODATA && roomBitMaps[b][BITMAP_Y] != BITMAP_NODATA)
    {
      if (roomY == 0 && roomBitMaps[b][BITMAP_Y] == 0)
        arduboy.drawBitmap(roomBitMaps[b][BITMAP_X], roomBitMaps[b][BITMAP_Y], outerWallImg, 8, 8, 1);
      else if (roomY == MAX_ROOM_Y - 1 && roomBitMaps[b][BITMAP_Y] == 56)
        arduboy.drawBitmap(roomBitMaps[b][BITMAP_X], roomBitMaps[b][BITMAP_Y], outerWallImg, 8, 8, 1);
      else if (roomX == 0 && roomBitMaps[b][BITMAP_X] == 0)
        arduboy.drawBitmap(roomBitMaps[b][BITMAP_X], roomBitMaps[b][BITMAP_Y], outerWallImg, 8, 8, 1);
      else if (roomX == MAX_ROOM_X - 1 && roomBitMaps[b][BITMAP_X] == 88)
        arduboy.drawBitmap(roomBitMaps[b][BITMAP_X], roomBitMaps[b][BITMAP_Y], outerWallImg, 8, 8, 1);
      else if ((roomX == 7 || roomX == 8 || roomX == 9) && roomY == 8)
        arduboy.drawBitmap(roomBitMaps[b][BITMAP_X], roomBitMaps[b][BITMAP_Y], exitRoomWallImg, 8, 8, 1);
      else if (roomX == 7 && roomY == 7 && (roomBitMaps[b][BITMAP_X] == 32 || roomBitMaps[b][BITMAP_X] == 40 || roomBitMaps[b][BITMAP_X] == 48 || roomBitMaps[b][BITMAP_X] == 56) && roomBitMaps[b][BITMAP_Y] == 56)
        arduboy.drawBitmap(roomBitMaps[b][BITMAP_X], roomBitMaps[b][BITMAP_Y], fenceImg, 8, 8, 1);
      else if (roomX == 8 && roomY == 9 && (roomBitMaps[b][BITMAP_X] == 32 || roomBitMaps[b][BITMAP_X] == 40 || roomBitMaps[b][BITMAP_X] == 48 || roomBitMaps[b][BITMAP_X] == 56) && roomBitMaps[b][BITMAP_Y] == 0)
        arduboy.drawBitmap(roomBitMaps[b][BITMAP_X], roomBitMaps[b][BITMAP_Y], fenceImg, 8, 8, 1);
      else if (roomX == 9 && roomY == 7 && (roomBitMaps[b][BITMAP_X] == 32 || roomBitMaps[b][BITMAP_X] == 40 || roomBitMaps[b][BITMAP_X] == 48 || roomBitMaps[b][BITMAP_X] == 56) && roomBitMaps[b][BITMAP_Y] == 56)
        arduboy.drawBitmap(roomBitMaps[b][BITMAP_X], roomBitMaps[b][BITMAP_Y], fenceImg, 8, 8, 1);
      else
        arduboy.drawBitmap(roomBitMaps[b][BITMAP_X], roomBitMaps[b][BITMAP_Y], innerWallImg, 8, 8, 1);
    }
  }
}

void DrawScores()
{
  arduboy.setTextSize(1);

  arduboy.setCursor(98, 10);
  PrintScore(CalcScore(score));

  if (cheat)
  {
    arduboy.setCursor(98, 0);
    if (roomX < 10)
      arduboy.print("0" + String(roomX) + ",");
    else
      arduboy.print(String(roomX) + ",");

    arduboy.setCursor(116, 0);
    if (roomY < 10)
      arduboy.print("0" + String(roomY));
    else
      arduboy.print(String(roomY));
  }

  arduboy.setCursor(98, 22);
  arduboy.print(String(CountFoundKeys()) + " / 4");

  DrawLives();

  DrawPct(pct, 102, 48);

  DrawfencingGauge();
}

void DrawFixedScores()
{
  arduboy.setTextSize(1);

  arduboy.setCursor(98, 0);
  arduboy.print("Score");

  arduboy.drawLine(98, 59, 127, 59, 1);
  arduboy.drawLine(98, 63, 127, 63, 1);
  arduboy.drawLine(98, 59, 98, 63, 1);
  arduboy.drawLine(127, 59, 127, 63, 1);
}

void DrawfencingGauge()
{
  unsigned int gauge = fencingGauge / 10;

  if (gauge > 25)
    gauge = 25;

  // fjern gauge
  arduboy.drawLine(100, 61, 125, 61, 0);
  
  if (gauge > 0)
    arduboy.drawLine(100, 61, 100 + gauge, 61, 1);
}

void DrawLives()
{
  // Undraw lives
  arduboy.fillRect(98, 34, 30, 8, 0);

  // heart 1
  if (lives > 1)
    arduboy.drawBitmap(98, 34, heartImgFull, 8, 8, 1);
  else if (lives == 1)
    arduboy.drawBitmap(98, 34, heartImgEmpty, 8, 8, 1);

  // heart 2
  if (lives > 3)
    arduboy.drawBitmap(107, 34, heartImgFull, 8, 8, 1);
  else if (lives == 3)
    arduboy.drawBitmap(107, 34, heartImgEmpty, 8, 8, 1);

  // heart 3
  if (lives > 5)
    arduboy.drawBitmap(116, 34, heartImgFull, 8, 8, 1);
  else if (lives == 5)
    arduboy.drawBitmap(116, 34, heartImgEmpty, 8, 8, 1);

  // extra lives
  if (lives > 6)
    arduboy.drawBitmap(125, 34, heartImgExtra, 3, 8, 1);
}

void DrawPct(byte pctValue, byte x, byte y)
{
  arduboy.setCursor(x, y);
  if (pctValue <= 9)
    arduboy.print("  " + String(pctValue) + "%");
  else if (pctValue <= 99)
    arduboy.print(" " + String(pctValue) + "%");
  else
    arduboy.print(String(pctValue) + "%");
}

unsigned int CalcScore(unsigned int score)
{
  return score + (pct * PCT_SCORE);
}

void PrintScore(unsigned int value)
{
  if (value < 10)
    arduboy.print("0000" + String(value));
  else if (value < 100)
    arduboy.print("000" + String(value));
  else if (value < 1000)
    arduboy.print("00" + String(value));
  else if (value < 10000)
    arduboy.print("0" + String(value));
  else
    arduboy.print("" + String(value));
}

void DrawAvatar(boolean lostLive)
{
  if (arduboy.everyXFrames(4) && (arduboy.pressed(LEFT_BUTTON) || arduboy.pressed(RIGHT_BUTTON) || arduboy.pressed(UP_BUTTON) || arduboy.pressed(DOWN_BUTTON)))
  {
    if (avatarFrame == 0)
      avatarFrame = 1;
    else
      avatarFrame = 0;
  }

  if (facingRight)
  {
    if (lostLive)
      arduboy.drawBitmap(avatarX, avatarY, avatarRightFallImg, AVATAR_WIDTH, AVATAR_HEIGHT, 1);
    else if (avatarFrame == 0)
    {
      if (fencing)
        arduboy.drawBitmap(avatarX, avatarY, avatarRight1fencingImg, AVATAR_WIDTH, AVATAR_HEIGHT, 1);
      else
        arduboy.drawBitmap(avatarX, avatarY, avatarRight1Img, AVATAR_WIDTH, AVATAR_HEIGHT, 1);
    }
    else
    {
      if (fencing)
        arduboy.drawBitmap(avatarX, avatarY, avatarRight2fencingImg, AVATAR_WIDTH, AVATAR_HEIGHT, 1);
      else
        arduboy.drawBitmap(avatarX, avatarY, avatarRight2Img, AVATAR_WIDTH, AVATAR_HEIGHT, 1);
    }
  }
  else
  {
    if (lostLive)
      arduboy.drawBitmap(avatarX, avatarY, avatarLeftFallImg, AVATAR_WIDTH, AVATAR_HEIGHT, 1);
    else if (avatarFrame == 0)
    {
      if (fencing)
        arduboy.drawBitmap(avatarX, avatarY, avatarLeft1fencingImg, AVATAR_WIDTH, AVATAR_HEIGHT, 1);
      else
        arduboy.drawBitmap(avatarX, avatarY, avatarLeft1Img, AVATAR_WIDTH, AVATAR_HEIGHT, 1);
    }
    else
    {
      if (fencing)
        arduboy.drawBitmap(avatarX, avatarY, avatarLeft2fencingImg, AVATAR_WIDTH, AVATAR_HEIGHT, 1);
      else
        arduboy.drawBitmap(avatarX, avatarY, avatarLeft2Img, AVATAR_WIDTH, AVATAR_HEIGHT, 1);
    }
  }
}

void UnDrawAvatar()
{
  arduboy.fillRect(avatarX, avatarY, AVATAR_WIDTH, AVATAR_HEIGHT, 0);
}

void DrawGhosts(byte ghostState)
{
  byte drawGhostState = 0;
  
  for (byte g = 0; g < currentNumGhosts; g++)
  {
    if (ghostState == GHOST_STATE_SELF)
      drawGhostState = ghosts[g][GHOST_STATE];
    else
      drawGhostState = ghostState;
    
    if (ghosts[g][GHOST_X] != NO_GHOST && ghosts[g][GHOST_X] != NO_GHOST)
    {
      if (ghosts[g][GHOST_TYPE] == GHOST_TYPE_GHOST)
      {
        if (drawGhostState == GHOST_STATE_NORMAL)
          arduboy.drawBitmap(ghosts[g][GHOST_X], ghosts[g][GHOST_Y], ghostFullImg, GHOST_WIDTH, GHOST_HEIGHT, 1);
        else if (drawGhostState == GHOST_STATE_HALF)
          arduboy.drawBitmap(ghosts[g][GHOST_X], ghosts[g][GHOST_Y], ghostDimmlImg, GHOST_WIDTH, GHOST_HEIGHT, 1);
        else if (drawGhostState == GHOST_STATE_GONE)
          arduboy.drawBitmap(ghosts[g][GHOST_X], ghosts[g][GHOST_Y], ghostDimm2Img, GHOST_WIDTH, GHOST_HEIGHT, 1);
      }
      else if (ghosts[g][GHOST_TYPE] == GHOST_TYPE_FOG)
      {
        arduboy.drawBitmap(ghosts[g][GHOST_X], ghosts[g][GHOST_Y], ghost2FullImg, GHOST_WIDTH, GHOST_HEIGHT, 1);
      }
    }
  }
}

void DrawGhost(byte ghostState, byte ghostNumber)
{
  if (ghosts[ghostNumber][GHOST_TYPE] == GHOST_TYPE_GHOST)
  {
    if (ghostState == GHOST_STATE_NORMAL)
      arduboy.drawBitmap(ghosts[ghostNumber][GHOST_X], ghosts[ghostNumber][GHOST_Y], ghostFullImg, GHOST_WIDTH, GHOST_HEIGHT, 1);
    else if (ghostState == GHOST_STATE_HALF)
      arduboy.drawBitmap(ghosts[ghostNumber][GHOST_X], ghosts[ghostNumber][GHOST_Y], ghostDimmlImg, GHOST_WIDTH, GHOST_HEIGHT, 1);
    else if (ghostState == GHOST_STATE_GONE)
      arduboy.drawBitmap(ghosts[ghostNumber][GHOST_X], ghosts[ghostNumber][GHOST_Y], ghostDimm2Img, GHOST_WIDTH, GHOST_HEIGHT, 1);
  }
  else if (ghosts[ghostNumber][GHOST_TYPE] == GHOST_TYPE_FOG)
  {
    arduboy.drawBitmap(ghosts[ghostNumber][GHOST_X], ghosts[ghostNumber][GHOST_Y], ghost2FullImg, GHOST_WIDTH, GHOST_HEIGHT, 1);
  }
}

void UnDrawGhosts()
{
  for (byte g = 0; g < currentNumGhosts; g++)
  {
    if (ghosts[g][GHOST_X] != NO_GHOST && ghosts[g][GHOST_X] != NO_GHOST)
      arduboy.fillRect(ghosts[g][GHOST_X], ghosts[g][GHOST_Y], GHOST_WIDTH, GHOST_HEIGHT, 0);
  }
}

void UnDrawGhost(byte ghostNumber)
{
  if (ghosts[ghostNumber][GHOST_X] != NO_GHOST && ghosts[ghostNumber][GHOST_Y] != NO_GHOST && ghosts[ghostNumber][GHOST_STATE] != NO_GHOST)
    arduboy.fillRect(ghosts[ghostNumber][GHOST_X], ghosts[ghostNumber][GHOST_Y], GHOST_WIDTH, GHOST_HEIGHT, 0);
}

void DrawExit()
{
  if (roomX == 8 && roomY == 8)
    arduboy.drawBitmap(36, 20, exitImg, EXIT_WIDTH, EXIT_HEIGHT, 1);
}

void DrawGameOverScreen()
{
  UnDrawAvatar();
  for (byte i = 0; i < 2; i++)
  {
    arduboy.drawBitmap(avatarX, avatarY, gameOverImg, 8, 8, 1);
    arduboy.display();
    delay(500);
    
    arduboy.fillRect(avatarX, avatarY, 8, 8, 0);
    arduboy.display();
    delay(500);
  }

  arduboy.drawBitmap(avatarX, avatarY, gameOverImg, 8, 8, 1);
  arduboy.display();
  delay(5000);  
}

//////////////////
// Key handling //
//////////////////
bool FenceOpen()
{
  if (CountFoundKeys() == NO_KEYS)
    return true;
  else
    return false;
}

void InitKeys()
{
  for (int i = 0; i < NO_KEYS; i++)
  {
    keys[i] = false;
  }
}

byte CountFoundKeys()
{
  byte counter = 0;
  for (byte i = 0; i < NO_KEYS; i++)
  {
    if (keys[i] == true)
      counter++;
  }

  return counter;
}

void CheckFindKeys()
{
  if (roomX == 2 && roomY == 14 && avatarX > 40 && avatarX < 56 && avatarY > 24 && avatarY < 40 && keys[0] == false)
  {
    keys[0] = true;
    UnDrawKey();
    score += KEY_SCORE;
  }
  else if (roomX == 7 && roomY == 14 && avatarX > 40 && avatarX < 56 && avatarY > 24 && avatarY < 40 && keys[1] == false)
  {
    keys[1] = true;
    UnDrawKey();
    score += KEY_SCORE;
  }
  else if (roomX == 4 && roomY == 9 && avatarX > 40 && avatarX < 56 && avatarY > 24 && avatarY < 40 && keys[2] == false)
  {
    keys[2] = true;
    UnDrawKey();
    score += KEY_SCORE;
  }
  else if (roomX == 9 && roomY == 3 && avatarX > 40 && avatarX < 56 && avatarY > 24 && avatarY < 40 && keys[3] == false)
  {
    keys[3] = true;
    UnDrawKey();
    score += KEY_SCORE;
  }
}

void DrawKey()
{
  if (roomX == 2 && roomY == 14 && keys[0] == false)
    arduboy.drawBitmap(44, 28, keyImg, KEY_WIDTH, KEY_HEIGHT, 1);
  else if (roomX == 7 && roomY == 14 && keys[1] == false)
    arduboy.drawBitmap(44, 28, keyImg, KEY_WIDTH, KEY_HEIGHT, 1);
  else if (roomX == 4 && roomY == 9 && keys[2] == false)
    arduboy.drawBitmap(44, 28, keyImg, KEY_WIDTH, KEY_HEIGHT, 1);
  else if (roomX == 9 && roomY == 3 && keys[3] == false)
    arduboy.drawBitmap(44, 28, keyImg, KEY_WIDTH, KEY_HEIGHT, 1);
}

void UnDrawKey()
{
  arduboy.fillRect(44, 28, KEY_WIDTH, KEY_HEIGHT, 0);
}

//////////////////
// Map handling //
//////////////////
void InitRoomMap()
{
  for(byte i = 0; i<BITMAPS; i++)
  {
    roomBitMaps[i][BITMAP_X] = BITMAP_NODATA;
    roomBitMaps[i][BITMAP_Y] = BITMAP_NODATA;
  }
}

void BuildRoomMap()
{
  numberBitMaps = 0;

  for (byte y = 0; y < ROOM_SIZE_Y; y++)
  {
    unsigned int pos = (y * MAX_ROOM_X) + roomX + (roomY * MAX_ROOM_X * ROOM_SIZE_Y);
    unsigned int roomLine = pgm_read_word_near(mapBits + pos);

    for (byte x = 0; x < ROOM_SIZE_X; x++)
    {
      if ((roomLine & bits[x]) == bits[x])
      {
        roomBitMaps[numberBitMaps][BITMAP_X] = x * WALL_SIZE_X;
        roomBitMaps[numberBitMaps][BITMAP_Y] = y * WALL_SIZE_Y;

        numberBitMaps++;
      }
    }
  }

  if (roomX == 8 && roomY == 9 && !FenceOpen())
  {
    roomBitMaps[numberBitMaps][BITMAP_X] = 32;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 0;
    numberBitMaps++;
    
    roomBitMaps[numberBitMaps][BITMAP_X] = 40;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 0;
    numberBitMaps++;

    roomBitMaps[numberBitMaps][BITMAP_X] = 48;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 0;
    numberBitMaps++;

    roomBitMaps[numberBitMaps][BITMAP_X] = 56;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 0;
    numberBitMaps++;
  }
  else if (roomX == 7 && roomY == 7 && !FenceOpen())
  {
    roomBitMaps[numberBitMaps][BITMAP_X] = 32;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 56;
    numberBitMaps++;

    roomBitMaps[numberBitMaps][BITMAP_X] = 40;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 56;
    numberBitMaps++;

    roomBitMaps[numberBitMaps][BITMAP_X] = 48;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 56;
    numberBitMaps++;

    roomBitMaps[numberBitMaps][BITMAP_X] = 56;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 56;
    numberBitMaps++;
  }
  else if (roomX == 9 && roomY == 7 && !FenceOpen())
  {
    roomBitMaps[numberBitMaps][BITMAP_X] = 32;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 56;
    numberBitMaps++;

    roomBitMaps[numberBitMaps][BITMAP_X] = 40;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 56;
    numberBitMaps++;

    roomBitMaps[numberBitMaps][BITMAP_X] = 48;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 56;
    numberBitMaps++;

    roomBitMaps[numberBitMaps][BITMAP_X] = 56;
    roomBitMaps[numberBitMaps][BITMAP_Y] = 56;
    numberBitMaps++;
  }
}

boolean GhostCollision(byte ghostNumber, byte ghostXNewPos, byte ghostYNewPos)
{
  return false;
}

boolean WallCollision(byte avatarNewX, byte avatarNewY, char* dir)
{
  for (byte b = 0; b <= numberBitMaps; b++)
  {
    if (roomBitMaps[b][BITMAP_X] != BITMAP_NODATA && roomBitMaps[b][BITMAP_Y] != BITMAP_NODATA)
    {
      if (dir == "D")
      {
        if ((avatarNewY + AVATAR_HEIGHT >= roomBitMaps[b][BITMAP_Y] && avatarNewY + AVATAR_HEIGHT <= roomBitMaps[b][BITMAP_Y] + WALL_SIZE_Y &&
             avatarNewX >= roomBitMaps[b][BITMAP_X] && avatarNewX <= roomBitMaps[b][BITMAP_X] + WALL_SIZE_X) ||
            (avatarNewY + AVATAR_HEIGHT >= roomBitMaps[b][BITMAP_Y] && avatarNewY + AVATAR_HEIGHT <= roomBitMaps[b][BITMAP_Y] + WALL_SIZE_Y &&
             avatarNewX + AVATAR_WIDTH >= roomBitMaps[b][BITMAP_X] && avatarNewX + AVATAR_WIDTH <= roomBitMaps[b][BITMAP_X] + WALL_SIZE_X))
          return true;
      }
      else if (dir == "U")
      {
        if ((avatarNewY >= roomBitMaps[b][BITMAP_Y] && avatarNewY <= roomBitMaps[b][BITMAP_Y] + WALL_SIZE_Y &&
             avatarNewX >= roomBitMaps[b][BITMAP_X] && avatarNewX <= roomBitMaps[b][BITMAP_X] + WALL_SIZE_X) ||
            (avatarNewY >= roomBitMaps[b][BITMAP_Y] && avatarNewY <= roomBitMaps[b][BITMAP_Y] + WALL_SIZE_Y &&
             avatarNewX + AVATAR_WIDTH >= roomBitMaps[b][BITMAP_X] && avatarNewX + AVATAR_WIDTH <= roomBitMaps[b][BITMAP_X] + WALL_SIZE_X))
          return true;
      }
      else if (dir == "R")
      {
        if ((avatarNewX + AVATAR_WIDTH >= roomBitMaps[b][BITMAP_X] && avatarNewX + AVATAR_WIDTH <= roomBitMaps[b][BITMAP_X] + WALL_SIZE_X &&
             avatarNewY >= roomBitMaps[b][BITMAP_Y] && avatarNewY <= roomBitMaps[b][BITMAP_Y] + WALL_SIZE_Y) ||
            (avatarNewX + AVATAR_WIDTH >= roomBitMaps[b][BITMAP_X] && avatarNewX + AVATAR_WIDTH <= roomBitMaps[b][BITMAP_X] + WALL_SIZE_X &&
             avatarNewY + AVATAR_HEIGHT >= roomBitMaps[b][BITMAP_Y] && avatarNewY + AVATAR_HEIGHT <= roomBitMaps[b][BITMAP_Y] + WALL_SIZE_Y))
          return true;
      }
      else if (dir == "L")
      {
        if ((avatarNewX >= roomBitMaps[b][BITMAP_X] && avatarNewX <= roomBitMaps[b][BITMAP_X] + WALL_SIZE_X &&
             avatarNewY >= roomBitMaps[b][BITMAP_Y] && avatarNewY <= roomBitMaps[b][BITMAP_Y] + WALL_SIZE_Y) ||
            (avatarNewX >= roomBitMaps[b][BITMAP_X] && avatarNewX <= roomBitMaps[b][BITMAP_X] + WALL_SIZE_X &&
             avatarNewY + AVATAR_HEIGHT >= roomBitMaps[b][BITMAP_Y] && avatarNewY + AVATAR_HEIGHT <= roomBitMaps[b][BITMAP_Y] + WALL_SIZE_Y))
          return true;
      }    
    }
  }

  return false;
}

void RoomChange()
{
  arduboy.clearDisplay();
  
  ghostInitCounter = 0;

  InitRoomMap();
  
  AddPctBits(roomX, roomY);
  BuildRoomMap();
  DrawWalls();
  DrawFixedScores();
  AddGhosts();

  pct = CalcPct();
}

/////////////////////
// Ghosts handling //
/////////////////////
void GhostsMovement()
{
  for (int g = 0; g < currentNumGhosts; g++)
  {
    boolean avatarXNegative = false;
    boolean avatarYNegative = false;
    
    if (avatarX < ghosts[g][GHOST_X])
      avatarXNegative = true;
    else
      avatarXNegative = false;
    
    if (avatarY < ghosts[g][GHOST_Y])
      avatarYNegative = true;
    else
      avatarYNegative = false;

    if (avatarXNegative)
    {
      if (!WallCollision(ghosts[g][GHOST_X] - GHOST_STEP_CHANGE, ghosts[g][GHOST_Y], "L") && 
          !GhostCollision(g, ghosts[g][GHOST_X] - GHOST_STEP_CHANGE, ghosts[g][GHOST_Y]))
        ghosts[g][GHOST_X] = ghosts[g][GHOST_X] - GHOST_STEP_CHANGE;
    }
    else
    {
      if (!WallCollision(ghosts[g][GHOST_X] + GHOST_STEP_CHANGE, ghosts[g][GHOST_Y], "R") &&
          !GhostCollision(g, ghosts[g][GHOST_X] + GHOST_STEP_CHANGE, ghosts[g][GHOST_Y]))
        ghosts[g][GHOST_X] = ghosts[g][GHOST_X] + GHOST_STEP_CHANGE;
    }
    
    if (avatarYNegative)
    {
      if (!WallCollision(ghosts[g][GHOST_X], ghosts[g][GHOST_Y] - GHOST_STEP_CHANGE, "U") &&
          !GhostCollision(g, ghosts[g][GHOST_X], ghosts[g][GHOST_Y] - GHOST_STEP_CHANGE))
        ghosts[g][GHOST_Y] = ghosts[g][GHOST_Y] - GHOST_STEP_CHANGE;
    }
    else
    {
      if (!WallCollision(ghosts[g][GHOST_X], ghosts[g][GHOST_Y] + GHOST_STEP_CHANGE, "D") &&
          !GhostCollision(g, ghosts[g][GHOST_X], ghosts[g][GHOST_Y] + GHOST_STEP_CHANGE))
        ghosts[g][GHOST_Y] = ghosts[g][GHOST_Y] + GHOST_STEP_CHANGE;
    }
  }
}

void NoGhosts()
{
  for (int g = 0; g < currentNumGhosts; g++)
  { 
    ghosts[g][GHOST_X]     = NO_GHOST;
    ghosts[g][GHOST_Y]     = NO_GHOST;
    ghosts[g][GHOST_STATE] = NO_GHOST;
    ghosts[g][GHOST_TYPE]  = NO_GHOST;
  }
}

void AddGhosts()
{
  if (roomX == 8 && roomY == 10) // Start room, no ghosts!
    NoGhosts();
  else
  {
    byte randX = 0;
    byte randY = 0;
    byte randG = 0;

    for (int g = 0; g < currentNumGhosts; g++)
    {
      boolean OkPosition = false;

      byte randXStart =  1;
      byte randXEnd   = 11;
      byte randYStart =  1;
      byte randYEnd   =  7;

      // Starting point of randow ghost X-pos
      if (avatarX < 10)
      {
        randXStart = 5;
        randXEnd = 11;
      } 
      else if (avatarX > 80)
      {
        randXStart = 1;
        randXEnd = 6;
      }

      // Starting point of randow ghost Y-pos
      if (avatarY < 10)
      {
        randYStart = 3;
        randYEnd = 7;
      }
      else if (avatarY > 50)
      {
        randYStart = 1;
        randYEnd = 5;
      }

      while (!OkPosition)
      {
        randX = random(randXStart, randXEnd);
        randY = random(randYStart, randYEnd);
        randG = random(GHOST_TYPE_GHOST, GHOST_TYPE_FOG + 1);
        
        OkPosition = OkGhostPosition(randX, randY);

        if (OkPosition)
        {
          ghosts[g][GHOST_X]     = randX * WALL_SIZE_X;
          ghosts[g][GHOST_Y]     = randY * WALL_SIZE_Y;
          ghosts[g][GHOST_STATE] = GHOST_STATE_NORMAL;
          ghosts[g][GHOST_TYPE]  = randG;
        }
      }
    }
  }
}

boolean OkGhostPosition(byte randX, byte randY)
{
  // check wall position
  unsigned int pos = (randY * MAX_ROOM_X) + roomX + (roomY * MAX_ROOM_X * ROOM_SIZE_Y);
  unsigned int roomLine = pgm_read_word_near(mapBits + pos);
  
  if ((roomLine & bits[randX]) == bits[randX])
    return false;
  else
  {
    // check avatar position
    if (randX == avatarX && randY == avatarY)
      return false;
    else
    {
      // check other ghost positions
      for (int g = 0; g < currentNumGhosts; g++)
      {
        if (randX * GHOST_WIDTH == ghosts[g][GHOST_X] && randY * GHOST_HEIGHT == ghosts[g][GHOST_Y])
          return false;
        else
          return true;
      }
    }
  }
}

boolean CollisionAvatarAndGhosts()
{
  if (roomX == 8 && roomY == 10) // Start room, no ghosts!
    return false;

  for (int g = 0; g < currentNumGhosts; g++)
  {
    int diffX = avatarX - ghosts[g][GHOST_X];
    int diffY = avatarY - ghosts[g][GHOST_Y];

    int diffXAbs = abs(diffX);
    int diffYAbs = abs(diffY);

    if (diffXAbs <= AVATAR_WIDTH && diffYAbs <= AVATAR_HEIGHT && ghosts[g][GHOST_STATE] == GHOST_STATE_NORMAL)
      return true;
  }

  return false;
}

byte AvatarKillingGhost()
{
  if (roomX == 8 && roomY == 10) // Start room, no ghosts!
    return NO_GHOST;

  if (fencing)
  {
    for (byte g = 0; g < currentNumGhosts; g++)
    {
      int diffX = avatarX - ghosts[g][GHOST_X];
      int diffY = avatarY - ghosts[g][GHOST_Y];

      int diffXAbs = abs(diffX);
      int diffYAbs = abs(diffY);

      if (diffXAbs <= AVATAR_WIDTH && diffYAbs <= AVATAR_HEIGHT && ghosts[g][GHOST_STATE] == GHOST_STATE_NORMAL &&
         ((avatarDirection == DIRECTION_RIGHT && ghosts[g][GHOST_X] > avatarX) || 
          (avatarDirection == DIRECTION_LEFT  && avatarX > ghosts[g][GHOST_X]) ||
          (avatarDirection == DIRECTION_UP    && avatarY > ghosts[g][GHOST_Y]) || 
          (avatarDirection == DIRECTION_DOWN  && ghosts[g][GHOST_Y] > avatarY)))
        return g;
    }
  }

  return NO_GHOST;
}

//////////////////
// Pct handling //
//////////////////
void InitPctBits()
{
  for (byte y = 0; y < PCT_BIT_BYTES; y++)
    pctBits[y] = 0;

  pct = 0;
}

void AddPctBits(byte x, byte y)
{
  pctBits[y] = pctBits[y] | bits[x];
}

byte CalcPct()
{
  byte calcBits = 0;
  for (byte y = 0; y < PCT_BIT_BYTES; y++)
  {
    for (byte x = 0; x < PCT_BIT_BYTES; x++)
    {
      if ((pctBits[y] & bits[x]) == bits[x])
        calcBits++;
    }
  }

  return (calcBits * 100) / 256;
}

/////////////////////
// Eeprom handling //
/////////////////////
void SaveHiscore(unsigned int score, byte pctScore)
{
  EEPROM.write(0, ((score >> 8) & 0xFF));
  EEPROM.write(1, (score & 0xFF));
  EEPROM.write(2, pctScore);
}

void FetchHiscore()
{
  // Hiscore
  byte hi = EEPROM.read(0);
  byte lo = EEPROM.read(1);

  unsigned int eepromHiscore = (hi << 8) | lo;
  
  if (eepromHiscore != 65535)
    hiscore = eepromHiscore;
  else 
    hiscore = 0;

  // Pct
  byte eepromPctHiscore = (byte)EEPROM.read(2);  
  
  if (eepromPctHiscore != 255)
    pctHiscore = eepromPctHiscore;
  else
    pctHiscore = 0;
}
